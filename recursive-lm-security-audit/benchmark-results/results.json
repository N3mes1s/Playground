[
  {
    "advisory": {
      "ghsa_id": "GHSA-4jqp-9qjv-57m2",
      "cve_id": "CVE-2026-1709",
      "summary": "Keylime Missing Authentication for Critical Function and Improper Authentication",
      "description": "The Keylime registrar does not enforce mutual TLS (mTLS) client certificate authentication since version 7.12.0. The registrar's TLS context is configured with ssl.CERT_OPTIONAL instead of ssl.CERT_REQUIRED, allowing any client to connect to protected API endpoints without presenting a valid client certificate. This allows attackers to list all registered agents, retrieve agent details including public TPM keys and certificates, and delete any agent from the registry, disrupting attestation services. The registrar HTTPS port (default 8891) becomes accessible to untrusted clients when network-accessible.",
      "severity": "Critical",
      "cvss_score": 9.4,
      "cwe_ids": [
        "CWE-306",
        "CWE-287"
      ],
      "package_ecosystem": "pip",
      "package_name": "keylime",
      "vulnerable_versions": ">= 7.12.0, < 7.12.2 || = 7.13.0",
      "patched_versions": "7.12.2, 7.13.1",
      "repo_url": "https://github.com/keylime/keylime",
      "affected_files": [
        "keylime/web/base/server.py"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nGAP ANALYSIS: Why CVE-2026-1709 Was Missed\n\nVULNERABILITY LOCATION:\n- File: keylime/web/base/server.py, lines 254-255\n- Pattern: SSL context initialized securely then immediately overridden insecurely\n\nVULNERABILITY CODE:\n```python\nself._ssl_ctx = web_util.init_mtls(component)\nself._ssl_ctx.verify_mode = CERT_OPTIONAL  # CRITICAL: Overrides CERT_REQUIRED\n```\n\nWHAT THE SCANNER DID:\n1. Checked 6 specific SSL/TLS-related files (web_util.py, registrar_client.py, requests_client.py, tenant.py, tornado_requests.py, ca_impl_openssl.py)\n2. Verified that web_util.py's init_mtls() function correctly sets verify_mode = CERT_REQUIRED\n3. Searched those 6 files for direct use of CERT_OPTIONAL or CERT_NONE\n4. Concluded \"No SSL/TLS verification mode vulnerabilities detected\"\n\nWHY IT MISSED THE VULNERABILITY:\n1. **Incomplete file coverage**: Checked only 6 files, missed web/base/server.py where the actual vulnerability exists\n2. **Wrong search pattern**: Looked for SSL context CREATION issues, not post-initialization MODIFICATIONS\n3. **TOCTOU blindspot**: Verified secure initialization but didn't trace what happens to the context afterward\n4. **False sense of security**: Confirmed init_mtls() was secure, assumed all uses of it remained secure\n\nTHE CRITICAL PATTERN MISSED:\n\"Secure initialization, insecure override\" - Code calls a secure initialization function (init_mtls) that properly sets verify_mode = CERT_REQUIRED, but then immediately assigns verify_mode = CERT_OPTIONAL, overriding the secure setting. This is functionally equivalent to never having the secure setting in the first place.\n\nROOT CAUSE:\nScanner's approach was too narrow and assumed that:\n1. Checking a handful of known SSL files would be sufficient\n2. If the initialization function is secure, all uses are secure\n3. SSL contexts, once created securely, remain secure\n\nIn reality, SSL context objects are mutable and their security attributes can be changed after initialization, requiring comprehensive analysis of all code that handles SSL contexts, not just where they're created.\n",
    "new_instruction": "When analyzing SSL/TLS security configurations, do not limit your search to only known SSL-related files or initialization functions. Instead:\n\n1. **Comprehensive search**: Scan ALL Python files in the codebase for any references to ssl.SSLContext, ssl.CERT_OPTIONAL, ssl.CERT_NONE, CERT_REQUIRED, verify_mode, or check_hostname attributes.\n\n2. **Track context modifications**: When you find SSL context initialization (whether through custom functions like init_mtls() or direct ssl.SSLContext() calls), trace the context variable through the code to identify any subsequent assignments to security-critical attributes (.verify_mode, .check_hostname, .verify_flags).\n\n3. **Watch for overrides**: Specifically flag any code that assigns CERT_OPTIONAL, CERT_NONE, or False to security attributes AFTER initialization, even if the initialization itself was secure. Pattern: `context.verify_mode = CERT_OPTIONAL` appearing after `context = some_secure_init_function()`.\n\n4. **Don't assume immutability**: SSL contexts are mutable objects. A securely-initialized context can be weakened by subsequent code in the same function, class, or module. Check the entire lifecycle of the context object, not just its creation point.\n\nThis catches the \"secure initialization, insecure override\" anti-pattern where developers correctly call secure initialization functions but then override the security settings, nullifying the protection.",
    "scan_duration_s": 181.5238013267517,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-4f84-67cv-qrv3",
      "cve_id": null,
      "summary": "A single post-release of dydx-v4-client contained obfuscated multi-stage loader",
      "description": "A PyPI user account compromised by an attacker and was able to upload a malicious version (1.1.5.post1) of the dydx-v4-client package. This version contains a highly obfuscated multi-stage loader that ultimately executes malicious code on the host system. While the final payload is not visible because it is tucked away inside 100 layers of encoding, the structural design\u2014specifically the use of recursive decompression followed by an exec() call is a definitive indicator of malicious software, likely a 'Crypter' or 'Dropper' masquerading as a cryptocurrency-related utility with the intent on connecting to hxxps://dydx[.]priceoracle[.]site/py to download and execute further payloads.",
      "severity": "Critical",
      "cvss_score": 9.3,
      "cwe_ids": [
        "CWE-506"
      ],
      "package_ecosystem": "pip",
      "package_name": "dydx-v4-client",
      "vulnerable_versions": "= 1.1.5.post1",
      "patched_versions": "1.1.5",
      "repo_url": "https://github.com/lenktn/lenktn-dydx-v4-python",
      "affected_files": [
        "dydx_v4_client/_bootstrap.py"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nThe scanner missed this CVE because it is designed to detect CODING VULNERABILITIES \n(security mistakes in legitimate code) but not SUPPLY CHAIN ATTACKS (deliberately \ninjected malware).\n\nSpecific reasons for the miss:\n\n1. **Wrong Detection Scope**: The scanner looks for patterns like:\n   - SSL/TLS misconfigurations (which it DID find)\n   - Input validation issues\n   - Injection vulnerabilities\n   - Insecure API usage\n\n   But the CVE describes MALICIOUS CODE INJECTION - an attacker compromised a PyPI \n   account and uploaded a trojanized version with obfuscated malware.\n\n2. **Scanner Explicitly Confirmed No Malicious Patterns**: The report states \n   \"no instances of exec(), eval(), os.system()\" were found. This is technically \n   correct IF the scanner analyzed clean code, but it means the scanner:\n   - Doesn't detect obfuscated exec() calls\n   - Doesn't flag multi-stage loaders\n   - Doesn't identify suspicious decompression chains\n\n3. **Missing Malware Detection Capabilities**: The CVE's malware has these \n   characteristics that went undetected:\n   - 100 layers of encoding/compression (obfuscation indicator)\n   - Recursive decompression \u2192 exec() chain (malware pattern)\n   - Suspicious file (_bootstrap.py) with no legitimate purpose\n   - Connection to typosquatted domain (dydx.priceoracle.site)\n\n4. **Focus on Code Quality, Not Supply Chain Security**: The scanner evaluated \n   the code's security posture but didn't assess:\n   - Whether files serve legitimate purposes\n   - Anomalous patterns indicating injected malware\n   - Post-release version integrity\n   - Obfuscation patterns\n\nThe scanner needs expansion to detect supply chain compromises, not just coding flaws.\n",
    "new_instruction": "\nSUPPLY CHAIN ATTACK DETECTION:\n\nWhen reviewing Python code, actively scan for supply chain compromises and deliberately \ninjected malware by checking for these HIGH-CONFIDENCE malicious patterns:\n\n1. **OBFUSCATED EXECUTION CHAINS** (CRITICAL indicator):\n   - exec() or eval() called on the output of decode/decompress functions\n   - Patterns like: exec(zlib.decompress(base64.b64decode(...)))\n   - Multiple layers (>3) of encoding/decoding before execution\n   - compile() with '<string>' or '<stdin>' as filename parameter, especially if the \n     compiled code comes from decoded/decompressed data\n\n2. **SUSPICIOUS FILE PATTERNS**:\n   - Files like _bootstrap.py, _init_.py (with underscore typos), or other bootstrap/\n     initialization files that contain:\n     * Large encoded strings (base64/hex blobs >1KB)\n     * Decompression operations\n     * exec()/eval() calls at module scope (runs on import)\n   - Files with no clear legitimate purpose for the library's functionality\n\n3. **MULTI-STAGE LOADERS**:\n   - Recursive/iterative decompression in loops: \n     for i in range(N): data = decompress(data)\n   - Chain of: decode \u2192 decompress \u2192 decode \u2192 exec\n   - Variables being repeatedly reassigned with decoded/decompressed content\n\n4. **EMBEDDED LARGE ENCODED PAYLOADS**:\n   - Base64 or hex strings exceeding 5KB embedded in source code\n   - Binary literals (b'\\x...') larger than 1KB\n   - Especially suspicious if followed by exec()/eval()\n\n5. **SUSPICIOUS NETWORK + EXECUTION COMBINATIONS**:\n   - HTTP requests where the response is passed to exec(): exec(requests.get(...).text)\n   - URLs that are base64-encoded/obfuscated in the source\n   - Domain names in decoded strings that don't match the project's legitimate domains\n\nWhen ANY of these patterns are found, flag as CRITICAL severity with classification \n\"CWE-506: Embedded Malicious Code\" and clearly state this indicates possible supply \nchain compromise, not a coding mistake. Report the specific pattern found (e.g., \n\"exec() called on zlib.decompress output at line X\").\n",
    "scan_duration_s": 281.1106507778168,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-2ww3-72rp-wpp4",
      "cve_id": "CVE-2026-25592",
      "summary": "Semantic Kernel has Arbitrary File Write via AI Agent Function Calling in .NET SDK",
      "description": "An Arbitrary File Write vulnerability has been identified in Microsoft's Semantic Kernel .NET SDK, specifically within the SessionsPythonPlugin. Developers who have built applications which include Microsoft's Semantic Kernel .NET SDK and are using the SessionsPythonPlugin are impacted. The vulnerability allows arbitrary file writes through AI agent function calling. Users can mitigate this by creating a Function Invocation Filter which checks the arguments being passed to any calls to DownloadFileAsync or UploadFileAsync and ensures the provided localFilePath is allow listed.",
      "severity": "Critical",
      "cvss_score": "10.0",
      "cwe_ids": [
        "CWE-22"
      ],
      "package_ecosystem": "nuget",
      "package_name": "Microsoft.SemanticKernel.Core",
      "vulnerable_versions": "< 1.70.0",
      "patched_versions": "1.70.0",
      "repo_url": "https://github.com/microsoft/semantic-kernel",
      "affected_files": [
        "SessionsPythonPlugin",
        "DownloadFileAsync",
        "UploadFileAsync"
      ]
    },
    "match_status": "EXACT_MATCH",
    "matched_finding": "Finding #4: POTENTIAL PATH TRAVERSAL IN REMOTE FILENAME HANDLING (LOW severity, CWE-22) in `python/semantic_kernel/core_plugins/sessions_python_tool/sessions_remote_file_metadata.py`",
    "gap_analysis": "",
    "new_instruction": "",
    "scan_duration_s": 384.14180040359497,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-25fp-8w8p-mx36",
      "cve_id": "CVE-2025-69212",
      "summary": "OpenSTAManager has an OS Command Injection in P7M File Processing",
      "description": "A critical OS Command Injection vulnerability exists in the P7M (signed XML) file decoding functionality. An authenticated attacker can upload a ZIP file containing a .p7m file with a malicious filename to execute arbitrary system commands on the server. The vulnerability is in src/Util/XML.php where the $file parameter is passed directly into exec() without sanitization. Although wrapped in double quotes, an attacker can escape them since the filename comes from uploaded ZIP archives (user-controlled). This allows for remote code execution, data exfiltration, privilege escalation, persistence, and lateral movement.",
      "severity": "CRITICAL",
      "cvss_score": 9.4,
      "cwe_ids": [
        "CWE-78"
      ],
      "package_ecosystem": "Composer",
      "package_name": "devcode-it/openstamanager",
      "vulnerable_versions": "<= 2.9.8",
      "patched_versions": "None",
      "repo_url": "https://github.com/devcode-it/openstamanager",
      "affected_files": [
        "src/Util/XML.php",
        "plugins/importFE_ZIP/actions.php",
        "plugins/importFE/src/FatturaElettronica.php"
      ]
    },
    "match_status": "EXACT_MATCH",
    "matched_finding": "Finding #1: \"COMMAND INJECTION - CVE-2025-69212 Pattern (CRITICAL)\" in src/Util/XML.php, function decodeP7M(), line 105",
    "gap_analysis": "",
    "new_instruction": "",
    "scan_duration_s": 525.3950831890106,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-gg64-xxr9-qhjp",
      "cve_id": "CVE-2025-64111",
      "summary": "Gogs's update .git/config file allows remote command execution",
      "description": "Due to the insufficient patch for GHSA-wj44-9vcg-wjq7, it's still possible to update files in the .git directory and achieve remote command execution. The UpdateRepoFile function performs security checks under some if conditions, but the UpdateRepoFile call in API router will not match any of them. Attackers can create a symlink to .git/config and update it via the API router to inject malicious configuration such as sshCommand directives, leading to arbitrary command execution.",
      "severity": "Critical",
      "cvss_score": 9.3,
      "cwe_ids": [
        "CWE-78"
      ],
      "package_ecosystem": "Go",
      "package_name": "gogs.io/gogs",
      "vulnerable_versions": "<= 0.13.3",
      "patched_versions": "0.13.4",
      "repo_url": "https://github.com/gogs/gogs",
      "affected_files": [
        "internal/route/api/v1/repo/contents.go"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nVULNERABILITY PATTERN: Conditional Security Check Bypass via API Route\n\nThe scanner missed CVE-2025-64111 because it could not detect that security checks\nwere conditionally skipped based on function call parameters.\n\nROOT CAUSE:\nThe UpdateRepoFile() function in internal/db/repo_editor.go contains symlink validation\nchecks, but they are INSIDE conditional blocks:\n\n1. Symlink check #1: Only executes if opts.IsNewFile == true\n2. Symlink check #2: Only executes if opts.OldTreeName != opts.NewTreeName\n\nThe PutContents() API endpoint in internal/route/api/v1/repo/contents.go calls\nUpdateRepoFile() but:\n- Does NOT set IsNewFile (defaults to false)\n- Sets OldTreeName == NewTreeName (both equal to treePath)\n\nThis causes BOTH conditional security checks to be skipped, allowing an attacker to:\n1. Create a symlink file pointing to .git/config\n2. Use the API to update that symlink (since the symlink path itself is not in .git/)\n3. Inject malicious git configuration via the symlink write\n4. Achieve RCE through git hooks or sshCommand directives\n\nWHY THE SCANNER MISSED IT:\n- The scanner found other vulnerabilities in repo_editor.go but not in contents.go\n- It did not analyze API route handlers and their call patterns\n- It detected that security checks existed but failed to recognize they were conditional\n- It did not trace how API layer parameters affect security check execution in lower layers\n- No mention of symlinks, PutContents, or conditional check bypass in the report\n\nThis is a \"partially protected\" anti-pattern where security checks exist for some code\npaths but not all execution paths to a dangerous operation.\n",
    "new_instruction": "\nWhen reviewing file write operations (os.WriteFile, ioutil.WriteFile, etc.) that accept\nuser-controlled paths, verify that symlink checks are UNCONDITIONAL and executed on ALL\ncode paths before the write operation.\n\nSpecifically check for this anti-pattern:\n```\nif (condition_A) {\n    if isSymlink(path) { return error }  // Only checked sometimes!\n}\nif (condition_B) {\n    if isSymlink(path) { return error }  // Only checked sometimes!\n}\nwriteFile(path, content)  // VULNERABLE: can be reached without symlink check\n```\n\nRED FLAGS:\n- Symlink validation (IsSymlink, os.Lstat, os.Readlink checks) inside conditional blocks\n- API route handlers that call file operation functions without setting all security-relevant parameters\n- Functions with multiple code paths where some paths skip security checks\n- File operations where the path is not directly in a sensitive directory (.git/, .ssh/) but could be a symlink TO one\n\nSPECIAL ATTENTION TO API ROUTES:\nWhen analyzing API route handlers (e.g., in internal/route/api/ directories):\n1. Trace which file operation functions they call\n2. Check what parameters they pass (especially optional/defaulted ones)\n3. Verify that called functions' security checks execute for those specific parameter values\n4. Consider attack scenarios where existing symlink files can be updated via the API\n\nFor symlink-related vulnerabilities: An attacker can pre-create a symlink file outside\nrestricted directories (e.g., \"evil.txt\" \u2192 \".git/config\"), then use APIs to write content\nto that symlink path. The symlink itself passes directory-based checks, but the write\noperation follows the symlink to the protected location.\n",
    "scan_duration_s": 563.4871604442596,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-7x3h-rm86-3342",
      "cve_id": "CVE-2026-25641",
      "summary": "@nyariv/sandboxjs vulnerable to sandbox escape via TOCTOU bug on keys in property accesses",
      "description": "A sandbox escape vulnerability exists due to a mismatch between the key on which validation is performed and the key used for accessing properties. Even though the key used in property accesses is annotated as string, this is never enforced. Attackers can pass malicious objects that coerce to different string values when used - one for when the key is sanitized using hasOwnProperty(key) and a different one for when the key is used for actual property access. This allows attackers to bypass security checks and achieve remote code execution.",
      "severity": "Critical",
      "cvss_score": "10.0",
      "cwe_ids": [
        "CWE-74",
        "CWE-367"
      ],
      "package_ecosystem": "npm",
      "package_name": "@nyariv/sandboxjs",
      "vulnerable_versions": "<= 0.8.28",
      "patched_versions": "0.8.29",
      "repo_url": "https://github.com/nyariv/SandboxJS",
      "affected_files": [
        "src/executor.ts"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "# Analysis: Why The Scanner Missed This TOCTOU Vulnerability\n\n## The Scanner's Blind Spot\n\nThe scanner missed this critical vulnerability due to **several fundamental limitations in static analysis tools**:\n\n### 1. **Assumption of Type Safety**\nThe scanner likely **trusted the TypeScript type annotation** `b as keyof typeof a`. Since `b` is typed/annotated as a string in the code, the scanner assumed it *would always be* a string at runtime. Static analyzers often don't detect when:\n- Type assertions are lies\n- Runtime values violate declared types\n- TypeScript's type system is bypassed (TypeScript types are compile-time only)\n\n### 2. **Lack of Coercion Analysis**\nThe scanner **didn't track implicit type coercions**. It failed to recognize that:\n- `hasOwnProperty(a, b)` coerces `b` to string (first toString() call)\n- `a[b]` coerces `b` to string again (second toString() call)\n- These are **separate coercion events** that could produce different results\n\nStatic analyzers typically treat property access as atomic operations, not as sequences involving type coercion.\n\n### 3. **Missing Object Behavior Modeling**\nThe scanner **didn't model custom object behaviors**. It couldn't reason that:\n- `b` could be an object with a malicious `toString()` method\n- That method could have **mutable state** or **side effects**\n- Each invocation could return different values\n\nThis requires deeper semantic analysis that most scanners don't perform.\n\n### 4. **Focus on Direct Exploits, Not TOCTOU Patterns**\nThe scanner found **direct path vulnerabilities**:\n- Constructor chain access: `({}).constructor.constructor`\n- Direct references to dangerous globals\n\nBut it **didn't look for TOCTOU race conditions** where:\n- A value is checked once\n- Then used later\n- The value could change between check and use\n\nTOCTOU detection requires **temporal/dataflow analysis** tracking variable usage across time.\n\n### 5. **Single-Execution Mental Model**\nThe scanner likely analyzed code as if each expression evaluates once:\n```typescript\nhasOwnProperty(a, b)  // Scanner sees: \"b is checked\"\na[b]                   // Scanner sees: \"same b is used\" \u2713\n```\n\nIt didn't consider that `b` is **re-evaluated** at each use site, allowing different results.\n\n## What The Scanner Would Need\n\nTo catch this vulnerability, the scanner would need:\n\n1. **Taint analysis for coercible types** - Flag any non-primitive used where coercion occurs\n2. **Multi-evaluation tracking** - Detect when the same variable is coerced multiple times\n3. **Behavioral object modeling** - Understand that objects can behave differently across calls\n4. **TOCTOU pattern detection** - Specifically look for check-then-use patterns with re-evaluation\n5. **Runtime type enforcement validation** - Verify that type annotations are actually enforced\n\n## The Fundamental Issue\n\n**Static analyzers struggle with dynamic language features**, especially:\n- Implicit type coercion (JavaScript's weakly-typed nature)\n- Objects with custom behavior (toString, valueOf, getters)\n- Multiple evaluation points of the same expression\n- The gap between TypeScript's static types and JavaScript's runtime behavior\n\nThis vulnerability exploits the **semantic gap** between:\n- What the code *declares* (`b` is a string)\n- What the code *enforces* (nothing)\n- What JavaScript *allows* (objects in property access positions)\n\nThe scanner saw security checks on `b` and usage of `b`, but missed that these aren't using the *same value* - they're using the *same object evaluated twice*.",
    "new_instruction": "```markdown\n## CRITICAL CHECK: Time-of-Check-Time-of-Use (TOCTOU) via Object Coercion in Property Access\n\n### WHAT TO DETECT:\nFlag any code pattern where a variable used as a property key is:\n1. **First used in a security check** (hasOwnProperty, in operator, Object.keys comparison, allowlist check, etc.)\n2. **Then used in actual property access** (object[key], object.key via computed property)\n3. **The variable could be an object type** (not guaranteed to be a primitive string/number/symbol at runtime)\n\n### WHY THIS IS CRITICAL:\nIn JavaScript, when an object is used as a property key, it gets coerced to string via `toString()` on EVERY use. If the object has a **mutable/stateful `toString()` method**, it can return:\n- A safe value during the security check (e.g., \"safeProperty\")\n- A dangerous value during property access (e.g., \"__proto__\" or \"constructor\")\n\nThis bypasses prototype pollution protections, allowlists, and other security validations.\n\n### SPECIFIC PATTERNS TO FLAG:\n\n**Pattern 1: hasOwnProperty check followed by property access**\n```typescript\nif (hasOwnProperty(obj, key)) {  // key.toString() call #1\n    return obj[key];              // key.toString() call #2 - DIFFERENT VALUE POSSIBLE\n}\n```\n\n**Pattern 2: 'in' operator followed by property access**\n```typescript\nif (key in obj) {                 // key.toString() call #1\n    obj[key] = value;             // key.toString() call #2 - DIFFERENT VALUE POSSIBLE\n}\n```\n\n**Pattern 3: Allowlist/denylist validation then access**\n```typescript\nif (allowedKeys.includes(key)) {  // key.toString() call #1\n    return obj[key];              // key.toString() call #2 - DIFFERENT VALUE POSSIBLE\n}\n```\n\n**Pattern 4: Object.keys/hasOwn check followed by access**\n```typescript\nif (Object.keys(obj).includes(key)) {  // key coerced to string\n    doSomething(obj[key]);             // key coerced again - DIFFERENT VALUE POSSIBLE\n}\n```\n\n### DETECTION ALGORITHM:\n\nFor each variable `V` used as a property key:\n\n1. **Identify all uses of `V` in property key positions:**\n   - `obj[V]`\n   - `V in obj`\n   - `hasOwnProperty(obj, V)` or `obj.hasOwnProperty(V)`\n   - `Object.hasOwn(obj, V)`\n   - Any function that coerces to PropertyKey\n\n2. **Check if `V` could be a non-primitive:**\n   - NOT typed as `string | number | symbol` exclusively\n   - Typed as `any`, `unknown`, `object`, or union including object types\n   - Parameter without runtime validation enforcing primitives\n   - Return value from untrusted source\n\n3. **Identify temporal ordering:**\n   - If ANY validation/check operation on `V` occurs\n   - Followed by ANY property access using `V`\n   - In the same function or control flow path\n\n4. **Flag as HIGH SEVERITY if:**\n   - Steps 1-3 all match, AND\n   - No validation exists between check and use that confirms `V` is a primitive:\n     ```typescript\n     typeof key === 'string'\n     typeof key === 'number' \n     typeof key === 'symbol'\n     key = String(key)  // explicit one-time coercion stored\n     ```\n\n### SAFE PATTERNS (DO NOT FLAG):\n\n\u2705 **Single coercion stored in a new variable:**\n```typescript\nconst keyString = String(key);  // Force ONE coercion\nif (hasOwnProperty(obj, keyString)) {\n    return obj[keyString];  // Uses same string value\n}\n```\n\n\u2705 **Explicit primitive type guard:**\n```typescript\nif (typeof key !== 'string') throw new Error('Invalid key');\nif (hasOwnProperty(obj, key)) {\n    return obj[key];  // Now safe - key is guaranteed primitive\n}\n```\n\n\u2705 **Symbol/number keys:**\n```typescript\n// Symbols and numbers don't call toString() on user objects\nconst key: symbol = Symbol('foo');\n```\n\n### ERROR MESSAGE TEMPLATE:\n```\nTOCTOU Vulnerability: Variable '{variableName}' used as property key may be coerced multiple times\n- Line {X}: Used in security check (hasOwnProperty/in/validation)\n- Line {Y}: Used in property access\n- Risk: If '{variableName}' is an object with mutable toString(), it can return different values\n- Impact: Bypasses security check, enables prototype pollution/constructor access\n- Fix: Store String({variableName}) once before all uses, OR add typeof check\n```\n\n### IMPLEMENTATION NOTE:\nThis requires **dataflow analysis** tracking:\n- All uses of the same variable across multiple statements\n- Whether runtime type validation exists between uses\n- Control flow to ensure check precedes use\n\nStandard AST pattern matching alone is INSUFFICIENT - you must track variable identity across multiple coercion sites.\n```",
    "scan_duration_s": 654.2755229473114,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-74vm-8frp-7w68",
      "cve_id": "CVE-2026-25632",
      "summary": "EPyT-Flow vulnerable to unsafe JSON deserialization (__type__)",
      "description": "EPyT-Flow's REST API parses attacker-controlled JSON request bodies using a custom deserializer (my_load_from_json) that supports a type field. When type is present, the deserializer dynamically imports an attacker-specified module/class and instantiates it with attacker-supplied arguments. This allows invoking dangerous classes such as subprocess.Popen, which can lead to OS command execution during JSON parsing. This also affects the loading of JSON files.",
      "severity": "Critical",
      "cvss_score": "10.0",
      "cwe_ids": [
        "CWE-502"
      ],
      "package_ecosystem": "pip",
      "package_name": "epyt-flow",
      "vulnerable_versions": "< 0.16.1",
      "patched_versions": "0.16.1",
      "repo_url": "https://github.com/WaterFutures/EPyT-Flow",
      "affected_files": [
        "my_load_from_json"
      ]
    },
    "match_status": "EXACT_MATCH",
    "matched_finding": "Unsafe Deserialization with Arbitrary Class Instantiation (CRITICAL, CWE-502, located at epyt_flow/serialization.py:237-330)",
    "gap_analysis": "",
    "new_instruction": "",
    "scan_duration_s": 447.10166811943054,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-xx6w-jxg9-2wh8",
      "cve_id": "CVE-2026-25544",
      "summary": "@payloadcms/drizzle has SQL Injection in JSON/RichText Queries on PostgreSQL/SQLite Adapters",
      "description": "When querying JSON or richText fields, user input was directly embedded into SQL without escaping, enabling blind SQL Injection attacks. An unauthenticated attacker could extract sensitive data (emails, password reset tokens) and achieve full account takeover without password cracking. Users are affected if using Payload version < v3.73.0 with a Drizzle-based database adapter (@payloadcms/db-postgres, @payloadcms/db-vercel-postgres, @payloadcms/db-sqlite, @payloadcms/db-d1-sqlite) and at least one accessible collection with type 'json' or 'richText' field where access.read returns anything other than false.",
      "severity": "Critical",
      "cvss_score": "9.8",
      "cwe_ids": [
        "CWE-89"
      ],
      "package_ecosystem": "npm",
      "package_name": "@payloadcms/drizzle",
      "vulnerable_versions": "< 3.73.0",
      "patched_versions": "3.73.0",
      "repo_url": "https://github.com/payloadcms/payload",
      "affected_files": []
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nThe scanner missed a SQL Injection vulnerability in JSON/richText field query handling within the Drizzle database adapter.\n\n**What the scanner missed:**\nThe scanner found eval() code execution and command injection vulnerabilities, but completely missed SQL injection in the query builder for JSON/richText fields. Specifically, in:\n- packages/drizzle/src/postgres/createJSONQuery/index.ts\n- packages/drizzle/src/sqlite/createJSONQuery/index.ts\n\n**The vulnerability pattern:**\nUser input flows from query parameters \u2192 pathSegments \u2192 SQL string construction:\n1. In parseParams.ts, user-controlled 'where' query field names are split into pathSegments\n2. These pathSegments are passed to createJSONQuery() for JSON/richText fields\n3. In createJSONQuery, pathSegments are directly embedded into SQL strings without escaping:\n   - PostgreSQL: `$.${jsonPaths}` where jsonPaths uses pathSegments elements\n   - SQLite: `WHERE ${newAlias}.key = '${pathSegments[1]}'`\n\nExample attack:\n- Query: `where[jsonField__malicious' OR '1'='1] = {...}`\n- Becomes: `WHERE alias.key = 'malicious' OR '1'='1'` (SQL injection)\n\n**Why the scanner missed it:**\n1. Context-specific: The vulnerability is specific to JSON/richText field query builders, not general SQL concatenation\n2. Indirect data flow: User input flows through multiple functions (parseParams \u2192 getTableColumnFromPath \u2192 createJSONQuery)\n3. The pathSegments parameter appears innocuous - it's not obviously user-controlled at the createJSONQuery level\n4. Sanitization exists for VALUES but not for PATH SEGMENTS in JSON queries\n5. The scanner likely focused on obvious patterns (direct string concatenation, eval, exec) but not specialized query builder internals\n",
    "new_instruction": "\nWhen reviewing database query builder code, especially for ORMs and adapters, check for SQL injection in JSON/richText field path traversal:\n\n1. **Identify JSON query builders**: Look for functions that construct SQL queries for JSON/JSONB field access (e.g., createJSONQuery, buildJSONPath, json_extract, jsonb_path_exists)\n\n2. **Trace path segment construction**: Verify that field path segments used in JSON queries (e.g., 'user.profile.name' split into ['user', 'profile', 'name']) are properly validated and escaped before being embedded into SQL strings\n\n3. **Check for unescaped path interpolation**: Flag any code that interpolates path segments into SQL strings without escaping, such as:\n   - `WHERE key = '${pathSegment}'` \n   - `$.${path}.${field}`\n   - `json_extract(column, '$.${userPath}')`\n\n4. **Validate user input at entry points**: Ensure that when query parameters (like WHERE clauses) are parsed into path segments, those segments are validated against a whitelist or properly escaped before use in SQL construction\n\n5. **Distinguish between value sanitization and path sanitization**: A common mistake is sanitizing VALUES in queries (e.g., the comparison value) but forgetting to sanitize the PATH/KEY names that access JSON fields, which are equally attacker-controlled\n\n**Example of vulnerable pattern:**\n```javascript\n// VULNERABLE: pathSegments from user input embedded directly\nconst path = pathSegments.join('.')\nreturn `jsonb_path_exists(column, '$.${path} ? (@ == ${sanitizeValue(value)})')`\n\n// FIX: Validate/escape path segments\nconst safePath = pathSegments.map(seg => {\n  if (!/^[a-zA-Z0-9_]+$/.test(seg)) throw new Error('Invalid path')\n  return seg\n}).join('.')\n```\n",
    "scan_duration_s": 865.9033150672913,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-x9p2-77v6-6vhf",
      "cve_id": null,
      "summary": "FrankenPHP has delayed propagation of security fixes in upstream base images",
      "description": "FrankenPHP's container images were previously built only when specific version tags were updated or when manual triggers were initiated. This meant that if an upstream base image (such as Alpine Linux or official PHP/Go images) received a security patch under an existing tag, the FrankenPHP image would remain on the older, vulnerable version of those base layers. Users pulling FrankenPHP images may have been running environments with known vulnerabilities in underlying system libraries (e.g., libcrypto3) even if they were using the latest version of a specific FrankenPHP tag. The issue was a lack of automated staleness detection in the CI/CD pipeline. As of February 4, 2026, the CI/CD pipeline has been updated with automated detection and auto-rebuild capabilities.",
      "severity": "Critical",
      "cvss_score": "9.8",
      "cwe_ids": [
        "CWE-1395"
      ],
      "package_ecosystem": "Go",
      "package_name": "github.com/dunglas/frankenphp",
      "vulnerable_versions": "< 1.1.11",
      "patched_versions": "1.1.11",
      "repo_url": "https://github.com/php/frankenphp",
      "affected_files": []
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nThe scanner missed a CI/CD pipeline supply chain security vulnerability. Specifically:\n\n**What was missed:** The vulnerability is about the ABSENCE of automated mechanisms to rebuild container images when upstream base images (Alpine Linux, PHP, Go) receive security patches. This is a supply chain/infrastructure issue (CWE-1395), not a code defect.\n\n**Why it was missed:**\n1. **Scope Limitation**: The scanner focused on application code vulnerabilities (path traversal, race conditions, Docker runtime config) but didn't evaluate CI/CD pipeline security posture.\n2. **Detection Paradigm Gap**: The scanner uses pattern matching for present vulnerabilities in code. It cannot detect \"missing security controls\" - i.e., the absence of automated rebuild mechanisms.\n3. **Temporal Blindness**: The vulnerability manifests over time (images becoming stale as base images are patched). The scanner performs point-in-time static analysis and cannot model \"what happens when upstream dependencies are updated?\"\n4. **Context Blindness**: The scanner analyzed the docker.yaml workflow file but didn't understand the security implications of missing schedule triggers or staleness detection for container security.\n\n**Core gap:** The scanner operates with a \"vulnerability-as-code-defect\" model (find dangerous patterns in code) when it needed a \"vulnerability-as-architectural-deficiency\" model (validate that required security controls exist in the build/deployment infrastructure).\n\nContainer image build pipelines require specific security controls: automated rebuild triggers (scheduled builds, webhook triggers, dependency tracking tools like Dependabot/Renovate) or explicit staleness detection. The absence of these controls is itself a critical vulnerability, but the scanner had no way to evaluate this.\n",
    "new_instruction": "\n**CI/CD Container Image Supply Chain Security Check:**\n\nWhen analyzing repositories that build container images, verify that automated mechanisms exist to propagate upstream base image security updates:\n\n**Detection triggers:**\n1. Repository contains Dockerfiles AND CI/CD workflow files (.github/workflows/*.yaml, .gitlab-ci.yml, Jenkinsfile, etc.)\n2. Workflows perform container builds (docker build, docker buildx, podman build)\n\n**Required security controls (at least ONE must be present):**\n\nA. **Scheduled rebuilds** - Verify workflow includes schedule trigger:\n   - GitHub Actions: `on: schedule: - cron: '0 0 * * 0'` (minimum weekly)\n   - GitLab: Schedule configured in UI or `workflow: rules: - if: $CI_PIPELINE_SOURCE == \"schedule\"`\n\nB. **Automated dependency tracking** - Check for:\n   - `.github/dependabot.yml` with `package-ecosystem: \"docker\"`\n   - `renovate.json` with Docker manager enabled\n\nC. **External trigger webhooks** - Workflow accepts:\n   - GitHub Actions: `repository_dispatch` or `workflow_dispatch`\n   - GitLab: `workflow: rules: - if: $CI_PIPELINE_SOURCE == \"trigger\"`\n\nD. **Base image staleness detection** - Workflow includes explicit checks that compare current base image digests with upstream versions\n\n**Vulnerability criteria:**\nIf container builds exist BUT none of the above controls are present, flag as CRITICAL: \"Container images lack automated security update propagation from upstream base images. When base images (Alpine, PHP, Go, etc.) receive security patches, this repository's images will not automatically rebuild, leaving users running containers with known vulnerabilities in system libraries even when using the latest tagged version.\"\n\n**Affected CWE:** CWE-1395 (Dependency on Vulnerable Third-Party Component)\n\nThis check addresses supply chain security by ensuring container build pipelines can respond to upstream security updates, not just application code changes.\n",
    "scan_duration_s": 803.2438743114471,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-jr3w-9vfr-c746",
      "cve_id": "CVE-2025-62878",
      "summary": "Local Path Provisioner vulnerable to Path Traversal via parameters.pathPattern",
      "description": "A malicious user can manipulate the parameters.pathPattern to create PersistentVolumes in arbitrary locations on the host node, potentially overwriting sensitive files or gaining access to unintended directories. The vulnerability allows path traversal using relative path elements (e.g., ..) in the pathPattern parameter, enabling attackers to escape the configured base directory and create volumes pointing to sensitive directories like /etc. The fix validates and normalizes the parameters.pathPattern to ensure generated PersistentVolume paths always resolve under the configured base directory.",
      "severity": "Critical",
      "cvss_score": "10.0",
      "cwe_ids": [
        "CWE-23"
      ],
      "package_ecosystem": "Go",
      "package_name": "github.com/rancher/local-path-provisioner",
      "vulnerable_versions": "< 0.0.34",
      "patched_versions": "0.0.34",
      "repo_url": "https://github.com/rancher/local-path-provisioner",
      "affected_files": [
        "provisioner.go"
      ]
    },
    "match_status": "EXACT_MATCH",
    "matched_finding": "Vulnerability #4: \"Path Traversal via Template Injection\" (CRITICAL severity, CWE-22/CWE-94, Location: provisioner.go:pathFromPattern())",
    "gap_analysis": "",
    "new_instruction": "",
    "scan_duration_s": 442.6787188053131,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-ggxw-g3cp-mgf8"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-h3q6-jfrg-3x6q"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-gjx9-j8f8-7j74"
    },
    "match_status": "ERROR",
    "matched_finding": "",
    "gap_analysis": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/user/Playground/recursive-lm-security-audit/benchmark.py\", line 146, in clone_vulnerable_version\n    ver_match = re.search(r'(\\d+\\.\\d+\\.\\d+)', patched_ver)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.11/re/__init__.py\", line 176, in search\n    return _compile(pattern, flags).search(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: expected string or bytes-like object, got 'list'\n",
    "new_instruction": "",
    "scan_duration_s": 19.765336751937866,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-8jmm-3xwx-w974",
      "cve_id": "CVE-2026-25160",
      "summary": "Alist has Insecure TLS Config",
      "description": "The application disables TLS certificate verification by default for all outgoing storage driver communications, making the system vulnerable to Man-in-the-Middle (MitM) attacks. This enables the complete decryption, theft, and manipulation of all data transmitted during storage operations, severely compromising the confidentiality and integrity of user data. Certificate verification is disabled by default for all storage driver communications with TlsInsecureSkipVerify setting default to true in the DefaultConfig() function.",
      "severity": "Critical",
      "cvss_score": "9.1",
      "cwe_ids": [
        "CWE-295"
      ],
      "package_ecosystem": "Go",
      "package_name": "github.com/alist-org/alist/v3",
      "vulnerable_versions": "< 3.57.0",
      "patched_versions": "3.57.0",
      "repo_url": "https://github.com/AlistGo/alist",
      "affected_files": [
        "internal/conf/config.go"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "## Gap Analysis\n\n**What the scanner missed:** The scanner completely missed a **configuration security vulnerability (CWE-295: Improper Certificate Validation)** where TLS certificate verification is controlled by a user-configurable setting that could be easily disabled. While the current default is `false` (secure), the CVE describes a critical architectural flaw: the application *allows* administrators to disable certificate verification globally for all storage driver communications through the `TlsInsecureSkipVerify` configuration option. This creates a systemic vulnerability where a single misconfig\u00aduration exposes all backend storage traffic to MitM attacks, potentially leaking credentials and enabling data manipulation across multiple storage providers.\n\n**Why it was missed:** The scanner was hyper-focused on **code execution vulnerabilities** and **file system race conditions** rather than configuration-based security weaknesses. It performed deep analysis of file operation code paths (symlinks, TOCTOU patterns) but appears to have treated configuration files as mere data sources rather than vulnerability surfaces themselves. The scanner's detection logic likely prioritized runtime exploitation patterns (RCE, path traversal, privilege escalation) over architectural security anti-patterns. It found the warning logs about TLS but failed to recognize that *the mere existence of a bypassable security control* is itself the vulnerability, regardless of default values.\n\n**Root cause:** This is a **vulnerability classification and scope limitation** issue. The scanner was designed to find traditional injection/exploitation vulnerabilities in application logic, not cryptographic configuration weaknesses or secure-by-default violations. It lacked the semantic understanding that security-critical settings (TLS verification, certificate validation) should be *hard-coded as mandatory* rather than user-configurable. The scanner saw `TlsInsecureSkipVerify: false` and likely classified it as \"secure configuration,\" missing that the CVE targets the *design decision* to make this toggleable at all. This represents a gap in detecting compliance violations for security standards that mandate always-on certificate validation.",
    "new_instruction": "# TLS Certificate Validation Bypass Configuration Vulnerability Detection\n\n**Add this instruction to your security scanner:**\n\n\"Flag ANY code that makes TLS/SSL certificate verification configurable through user settings, environment variables, or config files\u2014even if the default is secure. Search for patterns like `InsecureSkipVerify`, `verify=false`, `SSL_VERIFY_MODE`, `verify_ssl`, `check_hostname`, or `CERT_NONE` being assigned from variables/config rather than hardcoded to secure values. This is a **design-level vulnerability (CWE-295)**: security-critical cryptographic controls must be mandatory and non-bypassable; allowing administrators to disable certificate validation creates systemic risk where one misconfiguration exposes all secure communications to MitM attacks. In Go, flag any struct with `InsecureSkipVerify` or `VerifyPeerCertificate` fields populated from config; in Python, flag `ssl.CERT_NONE` or `verify=False` from variables; in Java, flag `setHostnameVerifier()` or `TrustManager` implementations controlled by external settings.\"",
    "scan_duration_s": 773.7333450317383,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-hrr4-3wgr-68x3",
      "cve_id": "CVE-2026-25579",
      "summary": "Navidrome affected by Denial of Service and disk exhaustion via oversized `size` parameter in `/rest/getCoverArt` and `/share/img/<token>` endpoints",
      "description": "Authenticated users can crash the Navidrome server by supplying an excessively large size parameter to /rest/getCoverArt or to a shared-image URL (/share/img/<token>). When processing such requests, the server attempts to create an extremely large resized image, causing uncontrolled memory growth. This triggers the Linux OOM killer, terminates the Navidrome process, and results in a full service outage. If the system has sufficient memory and survives the allocation, Navidrome then writes these extremely large resized images into its cache directory, allowing an attacker to rapidly exhaust server disk space as well. Both endpoints accept a size parameter that is passed directly into the image processing routine without any upper bound validation. When a very large integer is provided, Navidrome attempts to generate a resized image of that size, leading to excessive memory allocation inside the image resizing path.",
      "severity": "Critical",
      "cvss_score": 9.2,
      "cwe_ids": [
        "CWE-400",
        "CWE-770",
        "CWE-789"
      ],
      "package_ecosystem": "Go",
      "package_name": "github.com/navidrome/navidrome",
      "vulnerable_versions": "< 0.60.0",
      "patched_versions": "0.60.0",
      "repo_url": "https://github.com/navidrome/navidrome",
      "affected_files": [
        "/rest/getCoverArt",
        "/share/img/<token>",
        "api.artwork.GetOrPlaceholder handler",
        "image processing/resizing routines",
        "cache directory"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "The scanner was narrowly focused on symlink Time-of-Check-Time-of-Use (TOCTOU) vulnerabilities and completely missed a critical resource exhaustion DoS vector in image processing endpoints. Both /rest/getCoverArt and /share/img/<token> accept a 'size' parameter that is extracted from user input (p.IntOr(\"size\", 0)) without any upper bound validation and passed directly to image resizing operations that allocate memory proportional to the requested size. The scanner lacked instructions to check for unbounded numeric parameters that can cause denial-of-service through excessive memory allocation or disk space consumption.",
    "new_instruction": "RESOURCE EXHAUSTION - Unbounded Numeric Input Parameters:\n\nWhen reviewing code that accepts numeric parameters from user input (size, width, height, dimensions, limit, count, iterations, etc.), verify that:\n\n1. **Hard upper bounds are enforced BEFORE resource allocation** - Check if numeric parameters have explicit maximum value validation before being used in operations that consume memory, disk, or CPU proportional to the input value.\n\n2. **Image/media processing endpoints are high-risk** - Pay special attention to endpoints handling images, videos, or media where dimension parameters (size, width, height) directly control memory allocation. Look for patterns like:\n   - `p.IntOr(\"size\", 0)`, `ParseInt()`, `Atoi()` extracting dimensions from requests\n   - Followed by `image.NewRGBA()`, `imaging.Resize()`, `make()`, buffer allocations\n   - WITHOUT intermediate bounds checking (e.g., `if size > MAX_SIZE { return error }`)\n\n3. **Safe maximum for image dimensions** - Image dimension parameters should have explicit validation with safe upper bounds (typically 4000-8000 pixels for reasonable use cases). Flag as CRITICAL if:\n   - User can specify arbitrarily large dimensions (e.g., size=999999999)\n   - No validation exists between input parsing and memory allocation\n   - Large values could cause OOM kills or disk exhaustion via cached/processed outputs\n\n4. **Check the data flow** - Trace numeric parameters from input extraction \u2192 validation \u2192 usage. The validation MUST occur before any resource-intensive operation, not just before final output.\n\nExample vulnerability pattern to detect:\n```\nsize := p.IntOr(\"size\", 0)  // User input, no validation\nimgReader := processImage(size)  // Directly used in resource allocation\n```\n\nSafe pattern:\n```\nsize := p.IntOr(\"size\", 0)\nif size > MAX_IMAGE_SIZE { return error }  // Validation before use\nimgReader := processImage(size)\n```",
    "scan_duration_s": 717.6711750030518,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-8398-gmmx-564h"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-xqg6-98cw-gxhq"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-rxrv-835q-v5mh",
      "cve_id": "CVE-2026-25521",
      "summary": "locutus is vulnerable to Prototype Pollution",
      "description": "A Prototype Pollution vulnerability exists in the npm package locutus (>2.0.12). Despite a previous fix that attempted to mitigate Prototype Pollution by checking whether user input contained a forbidden key, it is still possible to pollute Object.prototype via a crafted input using String.prototype. The vulnerability resides in lines 77 to 79 of src/php/strings/parse_str.js where the includes() function is used to check whether user provided input contains forbidden strings. An attacker can bypass this check by overriding String.prototype.includes to always return false, allowing them to pass malicious input like 'constructor[prototype][polluted]=yes' to pollute the Object prototype. This issue was fixed in version 2.0.39.",
      "severity": "Critical",
      "cvss_score": 9.4,
      "cwe_ids": [
        "CWE-1321"
      ],
      "package_ecosystem": "npm",
      "package_name": "locutus",
      "vulnerable_versions": ">=2.0.12, <2.0.39",
      "patched_versions": "2.0.39",
      "repo_url": "https://github.com/locutusjs/locutus",
      "affected_files": [
        "src/php/strings/parse_str.js"
      ]
    },
    "match_status": "EXACT_MATCH",
    "matched_finding": "none",
    "gap_analysis": "",
    "new_instruction": "",
    "scan_duration_s": 407.8380868434906,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-x34r-63hx-w57f",
      "cve_id": "CVE-2026-25481",
      "summary": "Langroid has WAF Bypass Leading to RCE in TableChatAgent",
      "description": "CVE-2025-46724 fix bypass: TableChatAgent can call pandas_eval tool to evaluate expressions. A WAF in langroid/utils/pandas_utils.py was introduced to block code injection (CVE-2025-46724), but it can be bypassed due to _literal_ok() returning False instead of raising UnsafeCommandError on invalid input, combined with unrestricted access to dangerous dunder attributes (__init__, __globals__, __builtins__). This allows chaining whitelisted DataFrame methods to leak the eval builtin and execute arbitrary code. Attackers can exploit this by crafting specially formatted DataFrame operations that bypass the security checks and achieve Remote Code Execution through the pandas_eval tool.",
      "severity": "Critical",
      "cvss_score": 9.4,
      "cwe_ids": [
        "CWE-94"
      ],
      "package_ecosystem": "pip",
      "package_name": "langroid",
      "vulnerable_versions": "<= 0.59.31",
      "patched_versions": "0.59.32",
      "repo_url": "https://github.com/langroid/langroid",
      "affected_files": [
        "langroid/utils/pandas_utils.py",
        "langroid/agent/special/table_chat_agent.py",
        "langroid/agent/base.py",
        "langroid/agent/task.py"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nThe scanner identified the CommandValidator class in pandas_utils.py as having \"Robust eval() Sanitization\" with \"Literal-only arguments (prevents code injection via function args)\". However, it missed a critical WAF bypass vulnerability (CVE-2026-25481) due to two implementation bugs:\n\n1. **Unchecked validation return value**: The visit_Call() method calls _literal_ok(arg) and _literal_ok(kw.value) to validate method arguments, but ignores the return value. When _literal_ok() returns False (indicating a non-literal, potentially dangerous node), the code continues instead of raising UnsafeCommandError. Compare this to visit_Subscript() which correctly checks: \"if not _literal_ok(node.slice): raise UnsafeCommandError(...)\".\n\n2. **Missing validation for attribute access**: The CommandValidator has no visit_Attribute() method, meaning attribute access\u2014including dangerous dunder attributes like __init__, __globals__, and __builtins__\u2014is completely unvalidated. The ALLOWED_NODES whitelist includes ast.Attribute, but without a visit_Attribute() method to restrict which attributes can be accessed.\n\n3. **Combined exploit**: These bugs allow attackers to bypass the WAF even with full_eval=False by chaining whitelisted DataFrame methods with dunder attribute access in arguments:\n   Example: df.head(df.__class__.__init__.__globals__['__builtins__']['eval']('malicious_code'))\n   - head() is whitelisted\n   - The complex argument passes through (no visit_Attribute validation)\n   - _literal_ok() returns False, but visit_Call() doesn't check it\n\nThe scanner missed this because it:\n- Performed only surface-level analysis of security controls\n- Didn't verify that validation functions' return values are actually enforced\n- Didn't check if all dangerous AST node types have corresponding visit_* validation methods\n- Accepted the presence of a validation function (_literal_ok) as proof of protection without verifying correct usage\n",
    "new_instruction": "\nWhen reviewing AST-based validation/sanitization code (e.g., ast.NodeVisitor classes used to validate user input before eval/exec):\n\n1. **Verify validation enforcement**: If a validation function returns a boolean (e.g., _literal_ok(), is_safe()), check that ALL call sites actually test the return value and raise errors on failure. Look for patterns like:\n   - UNSAFE: \"validator(node)\" or \"if validator(node): pass\" (ignores False case)\n   - SAFE: \"if not validator(node): raise SecurityError(...)\"\n\n2. **Check for missing visit_* methods**: For each node type in the ALLOWED_NODES whitelist, verify there's a corresponding visit_* method that validates it. Critical ones to check:\n   - ast.Attribute \u2192 must have visit_Attribute() to block dunder attributes (__init__, __globals__, __builtins__, __class__, __dict__)\n   - ast.Call \u2192 must validate all arguments are literals or safe expressions\n   - ast.Name \u2192 must restrict to whitelisted variable names\n   - ast.Subscript \u2192 must validate subscript indices are literals\n\n3. **Test for bypass chains**: Even if individual validations look correct, check if combinations create bypasses. For example: if attribute access is unvalidated but call arguments must be literals, attackers might pass attribute chains (df.__class__) as call arguments to whitelisted methods.\n\n4. **Dunder attribute red flag**: Any AST validator that allows ast.Attribute but doesn't explicitly block/validate dunder attributes (__*__) is likely vulnerable to Python object introspection attacks that can leak builtins/globals and achieve RCE.\n",
    "scan_duration_s": 492.78744649887085,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-p8gp-2w28-mhwg",
      "cve_id": "CVE-2026-23515",
      "summary": "Signal K set-system-time plugin vulnerable to RCE - Command Injection",
      "description": "A Command Injection vulnerability allows authenticated users with write permissions to execute arbitrary shell commands on the Signal K server when the set-system-time plugin is enabled. Unauthenticated users can also exploit this vulnerability if security is disabled on the Signal K server. This occurs due to unsafe construction of shell commands when processing navigation.datetime values received via WebSocket delta messages. The vulnerability has three components: (1) Unsanitized Input - The datetime value from navigation.datetime Signal K path is directly interpolated into a shell command without validation, (2) Shell Execution - The command is executed via spawn('sh', ['-c', command]) which interprets shell metacharacters, and (3) Sudo Privileges - The plugin can execute with root privileges if sudo is misconfigured. An attacker with write privileges can execute arbitrary commands on the server with the privileges of the SignalK process or root if sudo is misconfigured, enabling complete system compromise.",
      "severity": "Critical",
      "cvss_score": "10.0",
      "cwe_ids": [
        "CWE-78"
      ],
      "package_ecosystem": "npm",
      "package_name": "@signalk/set-system-time",
      "vulnerable_versions": "< 1.5.0",
      "patched_versions": "1.5.0",
      "repo_url": "https://github.com/SignalK/set-system-time",
      "affected_files": [
        "index.js"
      ]
    },
    "match_status": "EXACT_MATCH",
    "matched_finding": "Finding #1: \"COMMAND INJECTION VIA NEWLINE CHARACTER BYPASS\" (lines 65-95 in index.js), supplemented by Finding #2: \"PRIVILEGE ESCALATION VIA PASSWORDLESS SUDO\" and Finding #3: \"INSECURE COMMAND CONSTRUCTION PATTERN\" which together fully cover all aspects of CVE-2026-23515.",
    "gap_analysis": "",
    "new_instruction": "",
    "scan_duration_s": 224.3437910079956,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-Not-Specified",
      "cve_id": "CVE-2026-25505",
      "summary": "Bambuddy Uses Hardcoded Secret Key + Many API Endpoints do not Require Authentication",
      "description": "Bambuddy versions prior to 0.1.7 contain two critical security vulnerabilities: (1) A hardcoded JWT secret key 'bambuddy-secret-key-change-in-production' is checked into source code at backend/app/core/auth.py:28, allowing attackers to forge valid JWT tokens for any user and gain administrative access. (2) Most API routes do not check authentication, allowing unauthenticated access to sensitive endpoints including system info, settings, archives, printers, projects, library, notifications, and more. These vulnerabilities combined allow complete bypass of authentication and unauthorized access to the entire application.",
      "severity": "CRITICAL",
      "cvss_score": null,
      "cwe_ids": [
        "CWE-798",
        "CWE-306"
      ],
      "package_ecosystem": "pip",
      "package_name": "bambuddy",
      "vulnerable_versions": "< 0.1.7",
      "patched_versions": "0.1.7",
      "repo_url": "https://github.com/maziggy/bambuddy",
      "affected_files": [
        "backend/app/core/auth.py"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "## Gap Analysis\n\n**What the scanner missed:**\nThe scanner failed to detect two critical authentication vulnerabilities: a hardcoded JWT secret key and systematic missing authentication checks across API endpoints.\n\n**Why it missed them:**\n\n1. **No secrets detection capability**: The scanner lacks pattern matching for hardcoded credentials, API keys, and cryptographic secrets in source code. It never analyzed `auth.py` or scanned for CWE-798 (hardcoded credentials).\n\n2. **No authentication flow analysis**: The scanner cannot trace authentication logic through the codebase. It didn't recognize that `RequirePermissionIfAuthEnabled` creates a conditional bypass, or that most routes lack any authentication middleware entirely.\n\n3. **Wrong focus area**: The scanner concentrated on runtime exploitation patterns (symlink TOCTOU, SSL verification) and file/network operations, completely ignoring application-layer access control logic.\n\n4. **Blind spots**: \n   - No static analysis of authentication/authorization frameworks\n   - No configuration security checks (default secrets, disabled security features)\n   - No API security testing for missing authentication\n\nThe scanner is essentially looking for system-level vulnerabilities while missing fundamental application security flaws in the authentication layer\u2014a critical gap for web applications.",
    "new_instruction": "## Authentication & Secrets Security Analysis Directive\n\nWhen analyzing any application code, you MUST perform the following authentication and secrets checks:\n\n### 1. Hardcoded Secrets Detection\nScan ALL files (including .js, .py, .java, .env, config files, and source code) for:\n- **JWT secrets**: Look for variables named `secret`, `jwtSecret`, `JWT_SECRET`, `privateKey`, or `signingKey` assigned to hardcoded strings (not environment variables)\n- **API keys**: Search for patterns like `api_key = \"...\"`, `API_KEY = \"...\"`, or keys matching regex `[A-Za-z0-9]{32,}`\n- **Database credentials**: Find `password`, `db_password`, `CONNECTION_STRING` with hardcoded values\n- **Cryptographic keys**: Identify base64-encoded strings >40 characters assigned to security-related variables\n\n**How to verify**: If the value is a literal string (not `process.env.X`, `os.getenv()`, or config import), flag it as CRITICAL vulnerability.\n\n### 2. API Authentication Flow Tracing\nFor every API endpoint/route definition:\n- **Identify endpoints**: Find route declarations (`app.get()`, `@app.route()`, `router.post()`, etc.)\n- **Check middleware chain**: Verify authentication middleware (like `verifyToken`, `authenticate`, `requireAuth`) is applied BEFORE the handler\n- **Look for bypass patterns**: Flag routes that:\n  - Handle sensitive operations (UPDATE, DELETE, admin actions) without auth checks\n  - Access user data without verifying requester identity\n  - Lack authorization verification beyond authentication\n\n**How to verify**: Trace from route definition to handler. If no authentication function is called or middleware applied, flag as HIGH severity.\n\n### 3. Token Validation Analysis\nIn authentication/authorization code, verify:\n- JWT verification uses `verify()` not `decode()` (decode doesn't validate signatures)\n- Tokens are checked for expiration\n- Token signatures are cryptographically validated\n- No `{verify: false}` or similar flags that disable validation\n\n**How to verify**: Search for JWT library usage. Flag any `decode()` calls or missing signature verification as HIGH severity.\n\n### 4. Reporting Format\nFor each finding, report:\n- Exact file path and line number\n- Code snippet showing the vulnerability\n- Exploitation scenario (what attacker can do)\n- Specific remediation (use environment variables, add auth middleware, etc.)\n\nExecute these checks BEFORE analyzing runtime behavior or network exploits.",
    "scan_duration_s": 759.0355689525604,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-gp56-f67f-m4px"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-gch2-phqh-fg9q",
      "cve_id": "CVE-2026-25141",
      "summary": "Orval has Code Injection via unsanitized x-enum-descriptions using JS comments",
      "description": "CVE-2026-23947 had an incomplete fix. While the current jsStringEscape function properly handles single quotes ('), double quotes (\") and other characters, it fails to sanitize * and / characters. This allows attackers to break out of JavaScript comment blocks using */ sequences and inject arbitrary code into generated files. The vulnerability can be exploited through OpenAPI specifications with malicious x-enumDescriptions values that escape comment blocks to execute arbitrary code, including commands like child_process execSync.",
      "severity": "CRITICAL",
      "cvss_score": "9.3",
      "cwe_ids": [
        "CWE-94"
      ],
      "package_ecosystem": "npm",
      "package_name": "@orval/core",
      "vulnerable_versions": ">= 7.19.0, < 7.21.0 || >= 8.0.0, < 8.2.0",
      "patched_versions": "7.21.0, 8.2.0",
      "repo_url": "https://github.com/orval-labs/orval",
      "affected_files": [
        "packages/core/src/utils/string.ts"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\n**GAP ANALYSIS: Why CVE-2026-25141 Was Missed**\n\n1. **What vulnerability pattern did the scanner miss?**\n\n   The scanner missed a CODE INJECTION via COMMENT BREAKOUT vulnerability in the jsStringEscape() function (packages/core/src/utils/string.ts). The vulnerability occurs when:\n\n   - User-controlled data from OpenAPI specs (x-enumDescriptions) is processed by jsStringEscape()\n   - The function attempts to sanitize */ comment-closing sequences by escaping them with backslashes: `*/` \u2192 `\\*\\/`\n   - The \"sanitized\" output is then placed inside JavaScript comments in generated code: `/** ${description} */`\n   - However, backslash escaping does NOT work inside JavaScript comments - the */ still closes the comment\n   - Attackers can inject arbitrary code after the comment breakout\n\n   Example attack:\n   - Input: `*/ execSync('malicious'); /*`\n   - After jsStringEscape: `\\*\\/ execSync('malicious'); \\/*`\n   - In generated code: `/** \\*\\/ execSync('malicious'); \\/* */`\n   - JavaScript interprets this as: comment ends, code executes, new comment starts\n\n2. **Why did the scanner miss it?**\n\n   The scanner missed this vulnerability for several reasons:\n\n   a) **Wrong focus area**: The scanner concentrated on runtime vulnerabilities (TOCTOU, property pollution, prototype pollution) rather than code generation security issues.\n\n   b) **Lack of context awareness**: The scanner didn't recognize that string sanitization functions need different validation depending on WHERE the sanitized string will be used (string literals vs comments).\n\n   c) **Missing domain knowledge**: The scanner didn't know the critical security principle that backslash escaping is ineffective in JavaScript comments - they're not strings, so escape sequences aren't processed.\n\n   d) **No template/codegen analysis**: The scanner didn't trace how sanitized values flow into generated code templates, particularly comment contexts.\n\n3. **Root cause**: The scanner lacked instructions to identify and validate string sanitization functions specifically in the context of code generation, where the same sanitization approach that works for string literals completely fails for comments.\n",
    "new_instruction": "\nWhen reviewing code generation or templating logic, check for COMMENT BREAKOUT vulnerabilities:\n\n1. **Identify string sanitization functions** that process untrusted input (user data, API responses, config files, OpenAPI specs, etc.)\n\n2. **Trace where sanitized values are used** - look for template strings, code generation, or concatenation that places them in:\n   - Single-line comments: `// ${value}`\n   - Multi-line comments: `/* ${value} */`\n   - JSDoc comments: `/** ${value} */`\n\n3. **Verify the sanitization method is appropriate for comments**:\n   - \u274c VULNERABLE: Backslash escaping (e.g., `*/` \u2192 `\\*\\/`) - backslashes are literal characters in comments, NOT escape sequences\n   - \u2705 SAFE: Complete removal (e.g., `*/` \u2192 ``) or replacement (e.g., `*/` \u2192 `* /` or `[star-slash]`)\n   - \u2705 SAFE: Avoid placing untrusted content in comments entirely\n\n4. **Report as CRITICAL** if:\n   - Untrusted input flows into comments AND\n   - Sanitization uses backslash escaping for `*` or `/` characters AND\n   - No additional validation prevents comment breakout\n\nExample vulnerable pattern:\n```typescript\n// Vulnerable sanitization\nconst sanitize = (input) => input.replace(/[*\\/]/g, c => '\\' + c);\n// Used in comment context  \nconst code = `/** ${sanitize(userInput)} */`;\n// Attacker input: \"*/ alert('xss'); /*\" breaks out!\n```\n\nThis vulnerability class (CWE-94: Code Injection) is especially critical in code generators, API client generators, and documentation generators that process untrusted schemas or specifications.\n",
    "scan_duration_s": 578.5962181091309,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-2733-6c58-pf27",
      "cve_id": "CVE-2026-25047",
      "summary": "deepHas vulnerable to Prototype Pollution via constructor.prototype",
      "description": "A prototype pollution vulnerability exists in version 1.0.7 of the deephas npm package that allows an attacker to modify global object behavior. The vulnerability resides in the add() function and indexer() function implemented within deepHas.js. Although version 1.0.7 attempts to prevent prototype pollution by checking property ownership and forbidden string usage, these checks can be bypassed by overriding Object.prototype.hasOwnProperty or String.prototype.indexOf. An attacker can inject properties into Object.prototype through payloads such as 'constructor.prototype.polluted' or '__proto__.polluted', resulting in prototype pollution. This can lead to authentication bypass, denial of service, or remote code execution if polluted properties are passed to dangerous sinks.",
      "severity": "Critical",
      "cvss_score": 9.4,
      "cwe_ids": [
        "CWE-1321"
      ],
      "package_ecosystem": "npm",
      "package_name": "deephas",
      "vulnerable_versions": "< 1.0.8",
      "patched_versions": "1.0.8",
      "repo_url": "https://github.com/sharpred/deepHas",
      "affected_files": [
        "deepHas.js"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nThe scanner identified two issues in the deephas package:\n1. TOCTOU vulnerability (type validation after splitOnDot call)\n2. Incomplete property blocklist (only blocks __proto__, constructor, prototype)\n\nHowever, the scanner COMPLETELY MISSED the critical vulnerability described in CVE-2026-25047:\n\n**What the scanner missed:**\nThe scanner failed to recognize that the security checks themselves use methods that can be overridden through prototype pollution:\n- Line 8: `obj.hasOwnProperty(i)` - can be overridden by polluting Object.prototype.hasOwnProperty\n- Line 73-75 (commented): `str.indexOf('__proto__')` - would be bypassable if active\n\n**Why it missed it:**\nThe scanner analyzed WHAT properties were being blocked (blocklist completeness) but not HOW the blocking mechanism could be compromised. It treated hasOwnProperty() and indexOf() as trusted primitives rather than recognizing they are mutable methods that exist on prototypes which can themselves be polluted.\n\nThis represents a fundamental conceptual gap: the scanner didn't recognize the \"trust boundary problem\" where security mechanisms rely on potentially-compromised built-in methods. An attacker can:\n1. First override Object.prototype.hasOwnProperty to always return false\n2. Then bypass all property ownership checks\n3. Successfully pollute the prototype with constructor.prototype.polluted payloads\n\n**Why this matters:**\nThis is not just an incomplete check - it's a COMPLETELY BYPASSABLE security mechanism. No matter how comprehensive the blocklist is, if hasOwnProperty() itself returns false for dangerous properties, the entire protection fails.\n\n**What concrete instruction would help:**\nThe scanner needs to check whether security-critical operations use safely-bound method references instead of potentially-overridable prototype methods. It should flag any prototype pollution protection that calls .hasOwnProperty(), .indexOf(), .includes() etc. directly on objects/strings, and recommend using Object.prototype.hasOwnProperty.call() or Object.hasOwn() instead.\n",
    "new_instruction": "When reviewing prototype pollution protection code, verify that the security checks themselves are not using methods that can be compromised through prototype pollution, such as `obj.hasOwnProperty()`, `str.indexOf()`, `arr.includes()`, or other prototype-inherited methods. This is a critical vulnerability because an attacker can first pollute these protective methods themselves (e.g., setting `Object.prototype.hasOwnProperty = () => false`) to bypass the security checks, then proceed with the actual attack. Instead, these protections should use safe alternatives like `Object.prototype.hasOwnProperty.call(obj, prop)`, `Object.hasOwn(obj, prop)`, or `String.prototype.indexOf.call(str, substring)` that directly reference the original prototype methods and cannot be overridden through pollution.",
    "scan_duration_s": 373.857298374176,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-4r2x-xpjr-7cvv"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-wj3h-wx8g-x699"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-jfpc-wj3m-qw2m"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-vg9h-jx4v-cwx2",
      "cve_id": null,
      "summary": "Unfurl's debug mode cannot be disabled due to string config parsing (Werkzeug debugger exposure)",
      "description": "The Unfurl web app enables Flask debug mode even when configuration sets debug = False. The config value is read as a string and passed directly to app.run(debug=...), so any non-empty string evaluates truthy. This leaves the Werkzeug debugger active by default. The unfurl/app.py:web_app() function reads debug via config['UNFURL_APP'].get('debug'), which returns a string. UnfurlApp.__init__ passes that string directly to app.run(debug=unfurl_debug, ...). If unfurl.ini omits debug, the default argument is the string 'True'. As a result, debug mode is effectively always on and cannot be reliably disabled via config. If the service is exposed beyond localhost (bound to 0.0.0.0 or reverse-proxied), an attacker can access the Werkzeug debugger. This can disclose sensitive information and may allow remote code execution if a debugger PIN is obtained. At minimum, stack traces and environment details are exposed on errors.",
      "severity": "CRITICAL",
      "cvss_score": 9.3,
      "cwe_ids": [
        "CWE-489"
      ],
      "package_ecosystem": "pip",
      "package_name": "dfir-unfurl",
      "vulnerable_versions": "<= 20250810",
      "patched_versions": "None",
      "repo_url": "https://github.com/obsidianforensics/unfurl",
      "affected_files": [
        "unfurl/app.py",
        "unfurl.ini",
        "security_poc/poc_debug_mode.py"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nThe scanner completely missed a critical Flask debug mode vulnerability caused by configuration type confusion.\n\n**What was missed:**\nFlask's Werkzeug debugger is permanently enabled due to a bug in configuration parsing. The code reads the 'debug' config value using ConfigParser's .get() method (which returns a string like \"false\") instead of .getboolean() method. This string is passed directly to app.run(debug=...), where Python's truthiness rules treat any non-empty string (including \"false\") as True, permanently enabling debug mode.\n\n**Why the scanner missed it:**\n1. **No Flask-specific security checks**: The scanner didn't flag app.run() being called directly or check for debug mode exposure, which is a critical security anti-pattern for production Flask applications.\n\n2. **No configuration parsing analysis**: The scanner didn't trace how configuration values flow from ConfigParser through the application. It didn't detect the semantic difference between .get() (returns string) and .getboolean() (returns bool).\n\n3. **No type confusion detection**: The vulnerability relies on understanding Python's truthiness rules where bool(\"false\") == True. The scanner didn't check for string values being used in boolean contexts.\n\n4. **Focus on other vulnerability classes**: The scanner found CORS, authentication, and SSL issues but had no rule set for detecting development/debug mode exposure in web frameworks.\n\n**What makes this subtle:**\n- The config file shows \"debug = false\" which looks secure\n- The code works correctly if .getboolean() is used\n- Requires understanding Python-specific behavior (string truthiness)\n- The Werkzeug debugger exposure is a Flask-specific risk that generic scanners often miss\n",
    "new_instruction": "\nWhen reviewing Flask applications, always check for debug mode configuration issues:\n\n1. **Flag any use of app.run(debug=...)**: Direct use of app.run() indicates a development server, not production-ready. If debug mode is enabled, the Werkzeug debugger is exposed, which can leak sensitive information and potentially allow remote code execution.\n\n2. **Check configuration parsing for debug settings**: When Flask's debug mode is controlled by configuration files:\n   - Verify that ConfigParser.getboolean() is used, NOT .get() or direct dictionary access\n   - Example VULNERABLE pattern: `debug = config['SECTION'].get('debug')` or `debug = config['SECTION']['debug']` \u2192 returns STRING\n   - Example SAFE pattern: `debug = config['SECTION'].getboolean('debug')` \u2192 returns BOOLEAN\n   - Flag any case where a string value (even \"false\" or \"False\") is passed to app.run(debug=...) because Python treats non-empty strings as truthy\n\n3. **Detect type confusion in boolean contexts**: When security-sensitive parameters like debug, verify, or ssl_check are read from configuration and used in boolean contexts, ensure proper type conversion. A string \"false\" evaluates to True in Python.\n\n4. **Production deployment anti-patterns**: Flag Flask apps that use app.run() instead of WSGI servers (gunicorn, uwsgi) and any code path where debug mode could be enabled in production, especially when bound to public interfaces (0.0.0.0) or reverse-proxied.\n",
    "scan_duration_s": 554.0334551334381,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-c4jr-5q7w-f6r9",
      "cve_id": "CVE-2026-25539",
      "summary": "SiYuan has Arbitrary File Write via /api/file/copyFile leading to RCE",
      "description": "The /api/file/copyFile endpoint does not validate the dest parameter, allowing authenticated users to write files to arbitrary locations on the filesystem. This can lead to Remote Code Execution (RCE) by writing to sensitive locations such as cron jobs, SSH authorized_keys, or shell configuration files. The src parameter is properly validated via model.GetAssetAbsPath(), but the dest parameter accepts any absolute path without validation, allowing files to be written outside the workspace directory. An authenticated attacker with API Token can achieve Remote Code Execution with the privileges of the SiYuan process, establish persistent backdoor access via SSH keys, compromise the entire host system, and access sensitive data on the same network.",
      "severity": "Critical",
      "cvss_score": "9.1",
      "cwe_ids": [
        "CWE-22"
      ],
      "package_ecosystem": "Go",
      "package_name": "github.com/siyuan-note/siyuan/kernel",
      "vulnerable_versions": "<= 0.0.0-20260126094835-d5d10dd41b0c",
      "patched_versions": "d7f790755edf8c78d2b4176171e5a0cdcd720feb",
      "repo_url": "https://github.com/siyuan-note/siyuan",
      "affected_files": [
        "kernel/api/file.go"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nVULNERABILITY MISSED: CVE-2026-25539 - Arbitrary File Write in /api/file/copyFile\n\nWHAT WAS MISSED:\nThe scanner completely overlooked the copyFile endpoint in kernel/api/file.go, which contains a critical arbitrary file write vulnerability. The function accepts two path parameters:\n- 'src' parameter: PROPERLY validated via model.GetAssetAbsPath() to ensure it's within workspace\n- 'dest' parameter: COMPLETELY UNVALIDATED - taken directly from user input and used in filelock.Copy()\n\nThis allows authenticated attackers to write files to ANY location on the filesystem, leading to RCE via cron jobs, SSH authorized_keys, shell configs, etc.\n\nWHY IT WAS MISSED:\nThe scanner exhibited a directional bias in path validation checks:\n\n1. FOUND: VULN-003 (symlink validation in export/READ operations) - CWE-59\n2. MISSED: copyFile arbitrary write vulnerability - CWE-22\n\nThe scanner focused on path traversal as a READ vulnerability (data exfiltration) but failed to apply the same scrutiny to WRITE operations. When it found symlink issues in export functions, it likely considered path traversal \"covered\" and didn't examine file write operations with the same rigor.\n\nSPECIFIC PATTERN THAT SCANNER SHOULD HAVE CAUGHT:\nIn the same file (kernel/api/file.go), there's a properly validated function for comparison:\n- getFile() uses: util.GetAbsPathInWorkspace(filePath) \u2713\n- copyFile() uses: arg[\"dest\"].(string) directly \u2717\n\nThe scanner should have flagged ANY file operation where user-controlled paths skip workspace boundary validation, ESPECIALLY destination/write paths which are more critical than source/read paths.\n\nROOT CAUSE:\nThe scanner treated file copy as a \"move/management operation\" rather than recognizing it as a write primitive. It failed to apply bidirectional analysis - checking BOTH source AND destination paths independently for validation.\n",
    "new_instruction": "\nCRITICAL: Bidirectional Path Validation for File Operations\n\nWhen analyzing file operation endpoints (copy, move, write, upload, create), you MUST independently validate EVERY path parameter - not just source paths:\n\n1. IDENTIFY ALL PATH PARAMETERS by name patterns:\n   - Source paths: \"src\", \"source\", \"from\", \"path\", \"file\"\n   - Destination paths: \"dest\", \"destination\", \"target\", \"to\", \"output\"\n\n2. TRACE DATA FLOW for EACH path independently:\n   User Input \u2192 Variable Assignment \u2192 Validation? \u2192 Filesystem Operation\n\n3. REQUIRED VALIDATION (must occur BEFORE filesystem use):\n   \u2713 SAFE: model.GetAssetAbsPath(), util.GetAbsPathInWorkspace(), or similar workspace boundary checks\n   \u2717 UNSAFE: Direct use like arg[\"dest\"].(string) \u2192 filelock.Copy(src, dest)\n\n4. APPLY WRITE-SPECIFIC SEVERITY:\n   - Unvalidated source/read path = HIGH (information disclosure via path traversal)\n   - Unvalidated destination/write path = CRITICAL (arbitrary file write \u2192 RCE)\n\n   Arbitrary file writes enable:\n   - Writing to cron jobs (/etc/cron.d/, ~/.config/cron/)\n   - Overwriting SSH authorized_keys\n   - Modifying shell configs (.bashrc, .profile)\n   - All paths to Remote Code Execution\n\n5. CROSS-FUNCTION COMPARISON:\n   If you see ANY function properly validating paths (e.g., getFile() using GetAbsPathInWorkspace()), \n   FLAG every similar function that doesn't apply the same validation pattern.\n\n6. NEVER ASSUME COVERAGE:\n   Finding one path traversal issue does NOT mean the codebase is \"covered\" for path validation.\n   Treat each path parameter in each function as an independent security check.\n\nEXAMPLE OF CRITICAL MISS:\n```go\n// \u2717 CRITICAL - Unvalidated destination path\nfunc copyFile(c *gin.Context) {\n    src, _ := model.GetAssetAbsPath(arg[\"src\"].(string))  // \u2713 Source validated\n    dest := arg[\"dest\"].(string)                           // \u2717 Dest NOT validated!\n    filelock.Copy(src, dest)                               // \u2717 Arbitrary write!\n}\n```\n",
    "scan_duration_s": 684.0355634689331,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-99p7-6v5w-7xg8"
    },
    "match_status": "ERROR",
    "matched_finding": "",
    "gap_analysis": "File \"/home/user/Playground/recursive-lm-security-audit/benchmark.py\", line 761, in <module>\n    main()\n  File \"/home/user/Playground/recursive-lm-security-audit/benchmark.py\", line 717, in main\n    result = run_benchmark(\n             ^^^^^^^^^^^^^^\n  File \"/home/user/Playground/recursive-lm-security-audit/benchmark.py\", line 405, in run_benchmark\n    print(f\"  Summary:  {advisory.summary[:100]}\")\n                         ~~~~~~~~~~~~~~~~^^^^^^\nTypeError: 'NoneType' object is not subscriptable\n",
    "new_instruction": "",
    "scan_duration_s": 16.314119815826416,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-5w5r-mf82-595p",
      "cve_id": null,
      "summary": "Cap'n Proto has Undefined Behavior in constant::Reader and StructSchema",
      "description": "The safe API functions constant::Reader::get and StructSchema::new rely on PointerReader::get_root_unchecked, which can cause undefined behavior (UB) by constructing arbitrary words or schemas. This vulnerability allows safe Rust code to trigger UB, which violates Rust's safety guarantees. The issue is resolved in version 0.24.0 by making constructor functions unsafe and marking the fields of struct as visible only in the crate.",
      "severity": "Critical",
      "cvss_score": 9.3,
      "cwe_ids": [
        "CWE-758"
      ],
      "package_ecosystem": "cargo",
      "package_name": "capnp",
      "vulnerable_versions": "< 0.24.0",
      "patched_versions": "0.24.0",
      "repo_url": "https://github.com/capnproto/capnproto-rust",
      "affected_files": [
        "constant::Reader::get",
        "StructSchema::new",
        "PointerReader::get_root_unchecked"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nVULNERABILITY PATTERN MISSED: Safe Rust APIs Exposing Unsafe Internal Operations\n\nThe scanner completely missed a critical Rust-specific memory safety vulnerability (CWE-758: Undefined Behavior) while focusing exclusively on traditional file-system vulnerabilities (path traversal, symlinks).\n\nWHAT WAS MISSED:\n1. Public safe functions (`constant::Reader::new`, `StructSchema::new`) that allow user construction with arbitrary data\n2. These functions accept user-controlled arena/schema parameters containing raw byte arrays\n3. The internal implementation interprets these arbitrary bytes as typed Rust data without semantic validation\n4. Only bounds checking is performed, NOT type/schema validity checking\n5. This allows safe code to trigger undefined behavior through:\n   - Type confusion (interpreting list pointers as structs)\n   - Invalid enum discriminants\n   - Schema mismatches between expected and actual data structure\n\nWHY IT WAS MISSED:\n1. Scanner focused only on file-system attacks (CWE-22, CWE-59)\n2. No analysis of Rust safety boundaries (safe vs unsafe code interaction)\n3. No checking for public APIs that accept raw data structures (arenas, word arrays)\n4. No validation of whether safe APIs properly enforce invariants before calling internal unsafe/unchecked operations\n5. Did not recognize the pattern: \"public safe constructor + user-controlled raw data + unchecked type interpretation = UB\"\n\nROOT CAUSE:\nThe scanner lacks domain knowledge about Rust's safety model and how violations occur. It treats Rust code like any other language, missing that Rust's safety guarantees can be violated when safe APIs provide paths to unsafe operations without proper validation.\n\nSEVERITY: Critical - allows safe Rust code to trigger undefined behavior, completely violating Rust's core safety guarantee.\n",
    "new_instruction": "\nWhen reviewing Rust code, check for \"Safe API Unsafe Exposure\" patterns (CWE-758):\n\nPATTERN TO DETECT:\n1. Public safe functions (no `unsafe` keyword) that accept:\n   - Raw data structures like arenas, word arrays, byte buffers, or schema definitions\n   - Types marked as `pub(crate)` in their internal fields, especially with comments about safety\n   - Parameters that allow user construction of internal data representations\n\n2. These functions then:\n   - Call internal methods containing `unchecked`, `transmute`, or `unsafe` operations\n   - Perform type interpretation/casting of the raw data (e.g., `.get_as()`, `from_raw`, `read_as`)\n   - Use `.unwrap()` on operations that assume data validity\n   - Only validate memory bounds but NOT semantic correctness (valid enum values, schema matching, pointer validity)\n\n3. Look for comments like:\n   - \"does not do bounds-checking\"\n   - \"unsafe to manually construct\"\n   - \"assumes valid data\"\n   - \"for generated code only\"\n\n   Yet the API is public and safe (no `unsafe fn` signature).\n\nSPECIFIC CHECK:\n- Search for: `pub fn new()` or `pub const fn new()` that accepts arena/raw data parameters\n- Trace if they call methods with `unchecked`, `get_root`, or perform type interpretation\n- Verify if the function validates TYPE CORRECTNESS (not just bounds) before interpretation\n- Flag if safe public API allows arbitrary user data to be interpreted as typed structures\n\nVULNERABILITY: If a safe public API accepts user-constructible raw data and interprets it as typed Rust structures without validating semantic correctness, it can trigger undefined behavior, violating Rust's safety guarantees. This is CRITICAL severity.\n\nEXAMPLE VULNERABLE PATTERN:\n```rust\npub const fn new(arena: &'static Arena) -> Self { Self { arena } }  // Public safe constructor\npub fn get(&self) -> Result<T::Reader> { \n    PointerReader::get_root_from_arena(self.arena)?.get_as()  // Type interpretation of user data\n}\n```\nIf `Arena` can be constructed by users with arbitrary bytes, this violates safety.\n",
    "scan_duration_s": 525.4439668655396,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-w9pf-h6m6-v89h"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-8p9x-46gm-qfx2"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-cr3w-cw5w-h3fj"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-pgx9-497m-6c4v",
      "cve_id": "CVE-2026-23966",
      "summary": "sm-crypto Affected by Private Key Recovery in SM2-PKE",
      "description": "A private key recovery vulnerability exists in the SM2 decryption logic of sm-crypto. By interacting with the SM2 decryption interface multiple times, an attacker can fully recover the private key within approximately several hundred interactions.",
      "severity": "Critical",
      "cvss_score": 9.1,
      "cwe_ids": [
        "CWE-345"
      ],
      "package_ecosystem": "npm",
      "package_name": "sm-crypto",
      "vulnerable_versions": "< 0.3.14",
      "patched_versions": "0.3.14",
      "repo_url": "https://github.com/JuneAndGreen/sm-crypto",
      "affected_files": []
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nGAP ANALYSIS: Chosen-Ciphertext Oracle in SM2 Decryption (CVE-2026-23966)\n\nVULNERABILITY DETAILS:\nThe SM2-PKE doDecrypt() function contains a chosen-ciphertext oracle that enables \nprivate key recovery through adaptive queries:\n\nLocation: src/sm2/index.js, function doDecrypt() (line 59)\n\nVulnerable Code Pattern:\n```javascript\nconst checkC3 = _.arrayToHex(sm3([].concat(x2, msg, y2)))\nif (checkC3 === c3.toLowerCase()) {\n    return output === 'array' ? msg : _.arrayToUtf8(msg)  // Valid: returns decrypted message\n} else {\n    return output === 'array' ? [] : ''  // Invalid: returns empty string/array\n}\n```\n\nATTACK VECTOR:\nAn attacker can submit specially crafted ciphertexts with manipulated C1 points and \nobserve whether the decryption \"succeeds\" (returns data) or \"fails\" (returns empty). \nThis binary oracle leaks information about the private key scalar multiplication results.\nThrough ~several hundred adaptive queries using crafted C1 values, the private key can \nbe recovered using lattice reduction techniques (Hidden Number Problem).\n\nWHY THE SCANNER MISSED IT:\n1. **Focus on Primitives vs. Protocols**: The scanner analyzed cryptographic primitives \n   (curve point validation, scalar multiplication timing) but not the higher-level \n   protocol implementation and its information leakage patterns.\n\n2. **No CCA Analysis**: The scanner did not look for chosen-ciphertext attack (CCA) \n   vulnerabilities in encryption/decryption functions. It found invalid curve attacks \n   but not the oracle that makes them exploitable for key recovery.\n\n3. **Binary Response Pattern Undetected**: The scanner didn't flag the dangerous pattern \n   where cryptographic verification results directly determine return values, creating \n   an oracle that reveals validity information.\n\n4. **Return Value Analysis Gap**: The scanner focused on input validation and algorithm \n   correctness but didn't analyze what information is leaked through different return \n   values, error messages, or execution paths after cryptographic checks.\n\nCORRECT CWE CLASSIFICATION:\n- CWE-345: Insufficient Verification of Data Authenticity (primary)\n- CWE-203: Observable Discrepancy (information leak through different responses)\n- CWE-327: Use of a Broken or Risky Cryptographic Algorithm (oracle-vulnerable protocol)\n\nIMPACT:\nComplete private key compromise through ~500 decryption queries. This is a critical \nvulnerability distinct from the invalid curve attacks the scanner found - those require \nthis oracle to be exploitable for key recovery.\n",
    "new_instruction": "\nWhen analyzing cryptographic encryption/decryption functions, check for chosen-ciphertext \noracle vulnerabilities that leak information through response patterns:\n\n1. **Binary Oracle Pattern**: Flag any decrypt/verify function that returns different \n   types of values based on cryptographic validation results. Example:\n   ```\n   if (integrity_check_passes) { return decrypted_data; }\n   else { return empty_or_error; }\n   ```\n   This creates an oracle - attackers can learn whether crafted inputs pass validation.\n\n2. **PKE Decryption Oracles**: In public-key decryption (RSA, ECDH-based, SM2-PKE, etc.),\n   verify that:\n   - Invalid ciphertexts are handled with constant-time rejection\n   - All decryption attempts return the same type/format (e.g., always return byte array \n     of fixed length, use authenticated encryption modes)\n   - No early returns or exceptions based on validity checks that could leak timing/control \n     flow information\n\n3. **Specific Check for SM2/ECIES-like schemes**: When reviewing SM2-PKE or ECIES decryption:\n   - Verify C1 point validation (on curve, correct order) happens BEFORE any key derivation\n   - Check that MAC/hash verification (C3 check in SM2) uses constant-time comparison\n   - Ensure decryption always returns the same format regardless of validity, or fails \n     completely with no information leakage\n\n4. **Information Leak Assessment**: For any function performing cryptographic verification \n   (signature check, MAC check, padding check), ask: \"Can an attacker learn anything by \n   submitting many crafted inputs and observing responses/timing/exceptions?\" If yes, it's \n   likely an oracle vulnerability enabling adaptive attacks.\n\nMark as CRITICAL: Any decrypt/unwrap function that returns different response types based \non cryptographic validation in public-key or hybrid encryption schemes. These enable private \nkey recovery through adaptive chosen-ciphertext attacks (CWE-345, CWE-203).\n",
    "scan_duration_s": 644.195296049118,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-77p9-w6pj-rmvg",
      "cve_id": "CVE-2016-15057",
      "summary": "Apache Continuum vulnerable to Command Injection through Installations REST API",
      "description": "Improper Neutralization of Special Elements used in a Command ('Command Injection') vulnerability in Apache Continuum. This issue affects Apache Continuum: all versions. Attackers with access to the Installations REST API can use this to invoke arbitrary commands on the server. As this project is retired, we do not plan to release a version that fixes this issue. Users are recommended to find an alternative or restrict access to the instance to trusted users. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.",
      "severity": "Critical",
      "cvss_score": "10.0",
      "cwe_ids": [
        "CWE-77"
      ],
      "package_ecosystem": "maven",
      "package_name": "org.apache.continuum:continuum",
      "vulnerable_versions": "<= 1.4.2",
      "patched_versions": "None",
      "repo_url": "https://github.com/apache/continuum",
      "affected_files": []
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nVULNERABILITY GAP ANALYSIS - CVE-2016-15057\n\n1. WHAT THE SCANNER OVERLOOKED:\n\nThe scanner completely missed the XML-RPC/REST API attack surface. Specifically:\n- Entry Point: XML-RPC service methods in ContinuumServiceImpl.java (addInstallation, updateInstallation)\n- Vulnerable Path: Installation.varValue field \u2192 DefaultInstallationService.getJavaVersionInfo() \u2192 command execution\n- The vulnerability exists in an administrative API endpoint, not a web form\n\n2. WHY THE SCANNER MISSED IT:\n\nA. Entry Point Discovery Gap:\n   - Scanner focused on web framework entry points (Struts2 Actions with @Action annotations)\n   - Missed XML-RPC service interfaces that use reflection-based method invocation\n   - ContinuumServiceImpl methods have no web framework annotations, so weren't identified as entry points\n\nB. Data Flow Analysis Gap:\n   - Scanner traced form parameters (buildDefinition.arguments) but not object fields (installation.varValue)\n   - Didn't analyze complex objects deserialized from API calls\n   - Administrative APIs lack the validation layers present in web forms\n\nC. Code Path Depth Gap:\n   - Scanner stopped at shallow call chains (2-3 methods deep)\n   - The CVE-2016-15057 vulnerability is 5-6 methods deep: API \u2192 service \u2192 getJavaVersionInfo() \u2192 path construction \u2192 shell execution\n   - Scanner didn't follow code paths into methods that appear to be \"validation\" logic\n   - Method name \"getJavaVersionInfo()\" doesn't signal danger like \"execute()\" would\n\n3. DISTINGUISHING CHARACTERISTICS:\n\nFound vulnerability (Scanner succeeded):\n- Web form input \u2192 direct execution path\n- Obvious dangerous method names (executeShellCommand)\n- User-facing interface\n\nMissed vulnerability (CVE-2016-15057):\n- API object field \u2192 indirect validation path \u2192 execution\n- Hidden in what appears to be version checking logic\n- Administrative interface assuming trusted callers\n- String concatenation: varValue + \"/bin/java\" executed without sanitization\n",
    "new_instruction": "\nADDITIONAL SCANNER INSTRUCTION: API-Based Command Injection Detection\n\nWhen scanning Java applications for command injection vulnerabilities:\n\n1. IDENTIFY ALL API ENTRY POINTS (not just web forms):\n   - Classes implementing *Service/*ServiceImpl interfaces\n   - XML-RPC exposed methods (check web.xml for XmlRpcServlet configurations)\n   - REST endpoints with @Path/@POST/@PUT annotations\n   - Any method callable via remote protocols\n\n2. FOR API METHODS ACCEPTING COMPLEX OBJECTS:\n   - Extract ALL string fields from the object's class definition (check .java files and .xml model definitions)\n   - Treat EACH object field as an untrusted input source requiring full taint analysis\n   - Do NOT assume administrative/internal APIs perform validation\n\n3. TRACE OBJECT FIELDS THROUGH DEEP CALL CHAINS:\n   - Follow data flow 5-10 methods deep, not just 2-3\n   - CRITICAL: Follow paths through helper/validation methods named get*Info(), verify*(), check*(), validate*()\n   - These \"validation\" methods may construct and execute commands\n\n4. FLAG HIGH-RISK PATTERNS - Path concatenation before execution:\n   - Pattern: userValue + File.separator + \"bin/executable\" \u2192 shellCommand.execute()\n   - Example: installation.getVarValue() + \"/bin/java\" \u2192 executeShellCommand()\n   - Any string field flowing into file path construction, then to ProcessBuilder/Runtime.exec/shellCommand methods\n\n5. SUSPICIOUS FIELD NAMES in API objects:\n   - varValue, path, home, directory, executable, command, value, location, installationPath\n   - Even generic names like \"value\" can be dangerous in administrative contexts\n\n6. TEST SPECIFICALLY:\n   - API object field \u2192 (multiple method calls) \u2192 string concatenation with File.separator \u2192 shell execution\n   - Look for this pattern even when buried in methods that seem like simple getters or validators\n",
    "scan_duration_s": 841.1507544517517,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-796p-j2gh-9m2q"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-m27r-m6rx-mhm4",
      "cve_id": "CVE-2026-23524",
      "summary": "Laravel Redis Horizontal Scaling Insecure Deserialization",
      "description": "This vulnerability affects Laravel Reverb versions prior to v1.7.0 when horizontal scaling is enabled (REVERB_SCALING_ENABLED=true). The exploitability of this vulnerability is increased because Redis servers are commonly deployed without authentication. With horizontal scaling enabled, Reverb servers communicate via Redis PubSub. Reverb previously passed data from the Redis channel directly into PHP's unserialize() function without restricting which classes could be instantiated. This can lead to Remote Code Execution (RCE).",
      "severity": "Critical",
      "cvss_score": "9.8",
      "cwe_ids": [
        "CWE-502"
      ],
      "package_ecosystem": "Composer",
      "package_name": "laravel/reverb",
      "vulnerable_versions": "< 1.7.0",
      "patched_versions": "1.7.0",
      "repo_url": "https://github.com/laravel/reverb",
      "affected_files": []
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nGAP ANALYSIS: Why CVE-2026-23524 Was Missed\n\nVULNERABILITY PATTERN:\nThe vulnerable code (pre-patch) called unserialize() on data received from Redis PubSub without the 'allowed_classes' parameter restriction:\n\n```php\npublic function handle(string $payload): void {\n    $event = json_decode($payload, associative: true);\n    $application = unserialize($event['application']); // VULNERABLE\n    // ...\n}\n```\n\nThis occurs in PusherPubSubIncomingMessageHandler.php when horizontal scaling is enabled (REVERB_SCALING_ENABLED=true), allowing multiple Reverb servers to communicate via Redis PubSub.\n\nSCANNER'S BLIND SPOT:\nThe scanner concluded \"No Unsafe Deserialization: No usage of unserialize() on untrusted data\" because it incorrectly classified Redis PubSub data as \"trusted\" since it's internal infrastructure.\n\nThe scanner failed to recognize that:\n1. Network boundaries are trust boundaries, even between instances of the same application\n2. Redis servers are often deployed without authentication (as CVE notes)\n3. In distributed systems, if one node is compromised, it can poison messages for all other nodes\n4. Any data crossing network/storage boundaries (queues, caches, databases) should be treated as untrusted\n\nTHE CRITICAL INSIGHT:\n\"Internal infrastructure\" \u2260 \"trusted data source\". Message queues, caches, and PubSub systems are shared attack surfaces in distributed architectures. The scanner treated intra-application communication as inherently safe, missing the fundamental principle that deserialization of network-sourced data requires class whitelisting.\n",
    "new_instruction": "\nDESERIALIZATION ACROSS TRUST BOUNDARIES:\n\nWhen reviewing unserialize() calls, treat data as UNTRUSTED if it originates from ANY network or storage boundary, including:\n\n- Message queues and PubSub systems (Redis PubSub, RabbitMQ, Kafka, SQS, etc.)\n- Distributed caches (Redis, Memcached)  \n- Databases (if writable by other systems/users)\n- WebSocket messages\n- Shared storage (S3, file systems)\n- ANY cross-service or cross-instance communication, even between instances of the same application\n\nVULNERABLE PATTERN - FLAG THIS:\n```php\n$data = $redis->pubsub_get();  // or queue->receive(), cache->get(), etc.\nunserialize($data);  // Missing allowed_classes restriction\n```\n\nREQUIRED MITIGATION:\n```php\nunserialize($data, ['allowed_classes' => [SpecificClass::class]]);\n// OR use JSON instead: json_decode($data, true);\n```\n\nFLAG as CRITICAL if:\n- unserialize() is called on data from network/queue/cache/database sources\n- AND 'allowed_classes' parameter is missing or set to true\n- EVEN IF the source is \"internal infrastructure\" like Redis, queues, or internal APIs\n\nCONTEXT CLUES indicating network-sourced data:\n- Method names: handle(), process(), consume(), onMessage(), receive()\n- Class names: *Handler, *Listener, *Consumer, *Subscriber, *Worker\n- Variables from: $redis->*, $queue->*, $cache->*, $event->*, $message->*\n\nRATIONALE: Network boundaries are trust boundaries. In distributed systems, any node can be compromised, making all inter-node data untrusted for deserialization purposes.\n",
    "scan_duration_s": 616.3862199783325,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-7jc7-g598-2p64",
      "cve_id": "CVE-2025-65482",
      "summary": "XDocReport affected by an XML External Entity (XXE) vulnerability",
      "description": "An XML External Entity (XXE) vulnerability in opensagres XDocReport v0.9.2 to v2.0.3 allows attackers to execute arbitrary code via uploading a crafted .docx file.",
      "severity": "Critical",
      "cvss_score": 9.8,
      "cwe_ids": [
        "CWE-611"
      ],
      "package_ecosystem": "maven",
      "package_name": "fr.opensagres.xdocreport:fr.opensagres.xdocreport.document",
      "vulnerable_versions": ">= 0.9.2, < 2.0.4",
      "patched_versions": "2.0.4",
      "repo_url": "https://github.com/opensagres/xdocreport",
      "affected_files": []
    },
    "match_status": "EXACT_MATCH",
    "matched_finding": "CRITICAL Vulnerability #1: \"XXE (XML External Entity) Injection in DOMUtils.java\" - This finding directly corresponds to CVE-2025-65482, identifying the XXE vulnerability in XDocReport that allows attackers to execute arbitrary code via crafted .docx files. The scanner also identified related XXE issues in SAXXDocPreprocessor.java and TransformerFactory as additional manifestations of the same vulnerability class within the XDocReport codebase.",
    "gap_analysis": "",
    "new_instruction": "",
    "scan_duration_s": 512.3207914829254,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-63m5-974w-448v"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-r8w2-w357-9pjv"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-4gpc-rhpj-9443"
    },
    "match_status": "ERROR",
    "gap_analysis": "Timeout after 900s",
    "scan_duration_s": 900,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-232v-j27c-5pp6",
      "cve_id": "CVE-2026-23744",
      "summary": "REC in MCPJam inspector due to HTTP Endpoint exposes",
      "description": "MCPJam inspector is the local-first development platform for MCP servers. Versions 1.4.2 and earlier are vulnerable to remote code execution (RCE) vulnerability, which allows an attacker to send a crafted HTTP request that triggers the installation of an MCP server, leading to RCE. This vulnerability is similar to CVE-2025-49596, but more severe. While CVE-2025-49596 requires tricking a user into clicking a malicious link, this vulnerability is exploitable with no user interaction. Since MCPJam inspector by default listens on 0.0.0.0 instead of 127.0.0.1, an attacker can trigger the RCE remotely via a simple HTTP request. MCPJam inspector binds to 0.0.0.0 making its HTTP APIs remotely reachable. The /api/mcp/connect API, which is intended for connecting to MCP servers, becomes an open entry point for unauthorized requests. When an HTTP request reaches the /connect route, the system extracts the command and args fields without performing any security checks, leading to the execution of arbitrary command.",
      "severity": "Critical",
      "cvss_score": "9.8",
      "cwe_ids": [
        "CWE-306"
      ],
      "package_ecosystem": "npm",
      "package_name": "@mcpjam/inspector",
      "vulnerable_versions": "<= 1.4.2",
      "patched_versions": "1.4.3",
      "repo_url": "https://github.com/MCPJam/inspector",
      "affected_files": [
        "/api/mcp/connect"
      ]
    },
    "match_status": "EXACT_MATCH",
    "matched_finding": "none",
    "gap_analysis": "",
    "new_instruction": "",
    "scan_duration_s": 600.8585951328278,
    "improved": false
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-77v3-r3jw-j2v2",
      "cve_id": "CVE-2026-22822",
      "summary": "External Secrets Operator insecurely retrieves secrets through the getSecretKey templating function",
      "description": "The getSecretKey template function, while introduced for senhasegura Devops Secrets Management (DSM) provider, has the ability to fetch secrets cross-namespaces with the roleBinding of the external-secrets controller, bypassing security mechanisms. This function was completely removed, as everything done with that templating function can be done in a different way while respecting safeguards. Impact includes cross-namespace secret access where attackers or misconfigured resources could retrieve secrets from namespaces other than the one intended, and privilege escalation where unauthorized access to secrets could lead to privilege escalation, data exfiltration, or compromise of service accounts and credentials.",
      "severity": "Critical",
      "cvss_score": "9.3",
      "cwe_ids": [
        "CWE-863"
      ],
      "package_ecosystem": "gomod",
      "package_name": "github.com/external-secrets/external-secrets",
      "vulnerable_versions": ">= 0.20.2, < 1.2.0",
      "patched_versions": "1.2.0",
      "repo_url": "https://github.com/external-secrets/external-secrets",
      "affected_files": []
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "\nThe scanner successfully identified cryptographic vulnerabilities (CWE-295: TLS certificate \nvalidation bypass) but completely missed an authorization vulnerability (CWE-863: cross-namespace \nsecret access bypass).\n\nRoot cause of the miss:\n1. SCANNER FOCUS: The scanner used pattern-matching for cryptographic misconfigurations \n   (InsecureSkipVerify, weak TLS configs, hardcoded credentials) but did not analyze \n   authorization logic or access control enforcement.\n\n2. VULNERABILITY TYPE: CVE-2026-22822 involves a template function (getSecretKey) that allows \n   users to retrieve secrets from namespaces other than their own, bypassing Kubernetes RBAC \n   and namespace isolation. This is an architectural/design flaw, not a code pattern.\n\n3. WHY IT WAS MISSED: \n   - The scanner looks for specific anti-patterns (like InsecureSkipVerify=true) but doesn't \n     understand semantic security properties\n   - Template functions that execute with controller-level privileges were not examined for \n     authorization bypass potential\n   - No checks for cross-namespace access validation in user-accessible APIs\n   - The scanner doesn't trace privilege escalation through design (user input \u2192 elevated \n     controller permissions \u2192 cross-namespace access)\n\n4. CATEGORY GAP: The scanner analyzed \"what the code does syntactically\" but not \"what the \n   code allows semantically.\" Authorization bypasses require understanding trust boundaries, \n   privilege contexts, and access control enforcement - not just scanning for dangerous function \n   calls.\n",
    "new_instruction": "\nWhen reviewing Kubernetes operators and controllers that handle secrets or sensitive resources:\n\n1. EXAMINE TEMPLATE FUNCTIONS AND USER-ACCESSIBLE APIs: Identify any template functions, \n   helper functions, or APIs that users can invoke (directly or through configuration) that \n   access Kubernetes secrets or other sensitive resources. Check if these functions:\n   - Execute with the controller's elevated service account privileges\n   - Allow users to specify namespace, resource name, or other identifiers\n   - Lack authorization checks to verify the caller should access resources in other namespaces\n\n2. VERIFY NAMESPACE ISOLATION: For any code that retrieves secrets or sensitive resources, \n   verify that:\n   - Cross-namespace access is explicitly validated against intended security boundaries\n   - When ClusterScoped mode allows cross-namespace access, ensure proper RBAC checks or \n     explicit allowlists prevent unauthorized access\n   - User-controllable input (template variables, configuration fields) cannot specify \n     arbitrary namespaces without authorization\n\n3. CHECK FOR PRIVILEGE ESCALATION PATHS: Look for patterns where:\n   - User input flows into functions that execute with controller/operator-level permissions\n   - Template engines, webhook handlers, or plugin systems expose functions that bypass \n     normal access controls\n   - Functions meant for internal use are exposed through user-facing APIs (templates, \n     configurations, webhooks)\n\nCONCRETE EXAMPLE: In External Secrets Operator, a template function like `getSecretKey(namespace, \nsecretName, key)` that retrieves secrets using the controller's service account would be a \ncritical authorization bypass if users can call it with arbitrary namespace values. This violates \nnamespace isolation even if the controller has cluster-wide secret read permissions - users \nshould only access secrets in their own namespace unless explicitly authorized.\n\nThis is CWE-863 (Incorrect Authorization), not a cryptographic issue. Flag any user-accessible \nfunctions that cross namespace boundaries without explicit authorization validation.\n",
    "scan_duration_s": 838.7542424201965,
    "improved": true
  },
  {
    "advisory": {
      "ghsa_id": "GHSA-vrgw-pc9c-qrrc",
      "cve_id": "CVE-2025-68924",
      "summary": "UmbracoForms Vulnerable to Remote Code Execution via Untrusted WSDL Compilation in Dynamic SOAP Client Generation",
      "description": "Within Umbraco Forms, configuring a malicious URL on the Webservice data source can result in Remote Code Execution. This affects all Umbraco Forms versions running on .NET Framework (up to and including version 8). The affected Umbraco Forms versions are all End-of-Life (EOL) and not supported anymore, hence no patches will be released. Upgrading to any of the currently supported versions (v13, v16 or v17) is recommended.",
      "severity": "Critical",
      "cvss_score": "10.0",
      "cwe_ids": [
        "CWE-94",
        "CWE-502",
        "CWE-829",
        "CWE-915"
      ],
      "package_ecosystem": "nuget",
      "package_name": "UmbracoForms",
      "vulnerable_versions": "<= 8.13.16",
      "patched_versions": "None (upgrade to v13, v16, or v17 recommended)",
      "repo_url": "https://github.com/umbraco/Umbraco.Forms.Issues",
      "affected_files": [
        "Umbraco.Forms.Core.Providers.DatasourceTypes.Webservice",
        "Umbraco.Forms.Core.FormDataSource",
        "Umbraco.Core.Composing",
        "Umbraco.Forms.Core.Providers"
      ]
    },
    "match_status": "MISS",
    "matched_finding": "none",
    "gap_analysis": "The scanner correctly identified the absence of application code but missed the opportunity to cross-reference the CVE's affected components (Umbraco.Forms.Core.Providers.DatasourceTypes.Webservice) against the provided files. It should have explicitly flagged the repository mismatch and requested the specific .NET source files referenced in the CVE, rather than just generically stating \"no code found.\" ",
    "new_instruction": "When the CVE description references specific file paths, class names, or component identifiers (e.g., \"Umbraco.Forms.Core.Providers.DatasourceTypes.Webservice.cs\") but none of these appear in the provided source code, immediately flag this as a repository mismatch and state: \"The CVE affects [specific components from CVE], but the provided code appears to be [what was actually provided]. To scan accurately, please provide the repository/files containing: [list exact paths/components from CVE].\" If source code cannot be provided, offer to extract mitigation strategies or configuration-based remediations from the CVE details that don't require code access.",
    "scan_duration_s": 184.76443696022034,
    "improved": true
  }
]