[
  {
    "cve_id": "CVE-2026-1709",
    "ghsa_id": "GHSA-4jqp-9qjv-57m2",
    "summary": "Keylime Missing Authentication for Critical Function and Improper Authentication",
    "cwe_ids": [
      "CWE-306",
      "CWE-287"
    ],
    "gap_analysis": "# Gap Analysis: Missed mTLS Verification Mode Misconfiguration\n\n## Missed Vulnerability Pattern\n\nThe scanner failed to detect the **TLS client certificate verification mode misconfiguration** where `ssl_ctx.verify_mode` is explicitly set to `ssl.CERT_OPTIONAL` instead of `ssl.CERT_REQUIRED` in a mutual TLS context. This is a distinct pattern from disabled hostname verification: the SSL context is correctly initialized for mTLS by `web_util.init_mtls()`, but line 254 immediately downgrades the verification mode, allowing clients to bypass certificate authentication. The scanner detected the boolean assignment `check_hostname = False` but missed the enumeration assignment `verify_mode = CERT_OPTIONAL`, despite both being critical TLS security controls.\n\n## Root Cause of Detection Failure\n\nThe scanner likely missed this pattern because its TLS authentication checks focused on **binary conditions** (authentication present/absent, hostname verification on/off) rather than **graduated verification modes**. While it detected the complete absence of authentication mechanisms and boolean flag misconfigurations, it did not evaluate SSL context properties that accept enumeration values (`CERT_NONE`, `CERT_OPTIONAL`, `CERT_REQUIRED`). The scanner may have confirmed that an mTLS context was initialized and marked authentication as \"present,\" without validating that the verification mode remained appropriately strict after initialization. This represents a gap in detecting *post-initialization degradation* of security controls.\n\n## Security Impact\n\nThis misconfiguration completely undermines the mTLS authentication boundary protecting the registrar's API. While `CERT_OPTIONAL` requests client certificates, it accepts connections even when none is provided, functionally equivalent to no authentication on the exposed HTTPS port (8891). Attackers gain unauthenticated access to enumerate all agents (`GET /agents/`), extract cryptographic material including TPM keys and certificates, and execute deletion operations that break attestation for arbitrary agents. The vulnerability is particularly severe because it defeats authentication while TLS encryption remains active, creating a false sense of security where encrypted-but-unauthenticated connections appear legitimate in logs and monitoring systems.",
    "instruction": "When reviewing SSL/TLS context configurations, flag any assignment where `verify_mode` is set to `ssl.CERT_OPTIONAL` or `ssl.CERT_NONE` (or their integer equivalents 0 or 1), particularly after an mTLS context has been initialized or on server-side sockets that should enforce client authentication. This configuration allows clients to connect without presenting valid certificates, completely bypassing mutual TLS authentication. For mTLS enforcement, `verify_mode` must be set to `ssl.CERT_REQUIRED` (or the integer value 2), and any downgrade from this setting should be flagged as a critical vulnerability.",
    "timestamp": "2026-02-09T09:04:00"
  },
  {
    "cve_id": "CVE-2025-69212",
    "ghsa_id": "GHSA-25fp-8w8p-mx36",
    "summary": "OpenSTAManager has an OS Command Injection in P7M File Processing",
    "cwe_ids": [
      "CWE-78"
    ],
    "gap_analysis": "\nVULNERABILITY MISSED: OS Command Injection in P7M File Processing (CVE-2025-69212)\n\nFILE: src/Util/XML.php, line 105\nVULNERABLE CODE:\n```php\n// Validation check\nif (preg_match('/[;&|`$(){}\\[\\]<>]/', $file)) {\n    throw new \\Exception('Invalid file path');\n}\n\n// Later: exec() call with user-controlled $file parameter\nexec('openssl smime -verify -noverify -in \"'.$file.'\" -inform DER -out \"'.$output_file.'\"', $output, $cmd);\n```\n\nWHY IT WAS MISSED:\n\n1. **Scanner's False Claim:** The scanner report stated \"No dangerous command execution functions (exec, shell_exec, system, passthru, etc.) were found in the codebase\" - this was INCORRECT. The exec() call at line 105 was not detected.\n\n2. **Insufficient Analysis Depth:** Even if the scanner had found the exec() call, it likely would have missed the vulnerability because:\n   - There IS input validation present (the preg_match check)\n   - The variable IS quoted in the shell command (double quotes)\n   - This creates false confidence that the code is safe\n\n3. **Incomplete Validation Not Recognized:** The validation regex checks for common shell metacharacters [;&|`$(){}\\[\\]<>] but critically OMITS:\n   - Newline characters (\\n, \\r)\n   - Null bytes (\\0)\n   - Other whitespace that can break shell parsing\n\n4. **Attack Vector:** An attacker can upload a ZIP file containing a .p7m file with a filename like:\n   `malicious.p7m\\nwhoami\\n`\n\n   This bypasses validation (no forbidden metacharacters) but when executed:\n   ```bash\n   openssl smime -verify -noverify -in \"malicious.p7m\n   whoami\n   \" -inform DER -out \"output\"\n   ```\n\n   The newline breaks out of the quoted context and executes arbitrary commands.\n\n5. **Root Cause of Miss:** Scanner did not:\n   - Exhaustively search for dangerous function calls (exec, shell_exec, system, passthru, proc_open)\n   - Trace user-controlled data flow (ZIP uploads \u2192 filenames \u2192 exec())\n   - Validate completeness of input sanitization (checking if ALL shell metacharacters are blocked)\n   - Understand that double-quoting in shell commands doesn't prevent newline injection\n\nSEVERITY: CRITICAL - Allows remote code execution by authenticated users\n",
    "instruction": "\nWhen reviewing code for command injection vulnerabilities:\n\n1. **Exhaustively search for ALL dangerous shell execution functions**: exec(), shell_exec(), system(), passthru(), proc_open(), popen(), backticks (`). Do NOT assume they don't exist - actually search the codebase.\n\n2. **For EACH dangerous function found, verify:**\n   - Does user-controlled input (file uploads, form data, URL parameters, filenames from archives) flow into the command?\n   - Even if there's validation, is it COMPLETE?\n\n3. **Validation completeness check - if user input goes into shell commands, the validation MUST block ALL of these:**\n   - Command separators: ; & | && ||\n   - Command substitution: ` $ ( )\n   - Redirection: < > >> 2>&1\n   - Wildcards: * ? [ ]\n   - **CRITICAL: Newlines and whitespace: \\n \\r \\r\\n \\t \\0**\n   - Other shell specials: ~ ! # { }\n\n4. **Quoting is NOT sufficient protection:**\n   - Single quotes ('): Can be broken with newlines in some contexts\n   - Double quotes (\"): Do NOT prevent newline injection - \\n breaks out and executes new commands\n   - Escaping must be comprehensive or better yet, avoid shell execution entirely\n\n5. **Specific pattern to flag as CRITICAL:**\n   ```php\n   // VULNERABLE even with validation if newlines aren't blocked:\n   if (preg_match('/[;&|`$()...]/', $user_input)) { /* validation */ }\n   exec(\"command \\\"$user_input\\\"\");  // Newline in $user_input still allows injection!\n   ```\n\n6. **Recommended secure pattern:**\n   - Use escapeshellarg() in PHP (properly escapes ALL shell metacharacters including newlines)\n   - Or better: Avoid shell execution entirely - use native PHP functions, libraries, or exec() with array arguments where supported\n   - If validation is used, verify it blocks: /[;&|`$(){}\\[\\]<>\\n\\r\\t\\x00*?~!#]/\n\nWhen you find exec/shell_exec/system/passthru with user input, even if there's validation and quoting, check if the validation blocks newlines (\\n, \\r). If not, flag as CRITICAL command injection vulnerability.\n",
    "timestamp": "2026-02-09T09:14:30"
  }
]