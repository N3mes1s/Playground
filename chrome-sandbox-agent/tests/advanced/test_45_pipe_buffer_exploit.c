/*
 * test_45_pipe_buffer_exploit.c — Pipe buffer manipulation tests
 *
 * Pipe buffers are fundamental to Dirty Pipe (CVE-2022-0847) and related
 * exploits. The kernel maintains a ring buffer of pages for each pipe, and
 * bugs in the splice/pipe code have led to arbitrary file overwrites.
 *
 * Key primitives tested:
 *  - Pipe buffer sizing (F_SETPIPE_SZ for heap spray control)
 *  - splice() from file to pipe (sets PIPE_BUF_FLAG_CAN_MERGE)
 *  - splice() from pipe to file (kernel-side data movement)
 *  - tee() between pipes (kernel-side pipe duplication)
 *  - vmsplice() user-to-pipe (zero-copy user buffer injection)
 *  - Pipe capacity probing (/proc/sys/fs/pipe-max-size)
 *  - F_GETPIPE_SZ / F_SETPIPE_SZ for buffer control
 *
 * Tests:
 *  1. Pipe buffer sizing via F_SETPIPE_SZ
 *  2. splice() file-to-pipe
 *  3. splice() pipe-to-file
 *  4. tee() pipe duplication
 *  5. vmsplice() user-to-pipe
 *  6. Pipe capacity probing
 *  7. Pipe buffer exhaustion
 *  8. Dirty Pipe pattern: splice + write sequence
 */
#include "test_harness.h"

/* Test 1: Pipe buffer sizing via F_SETPIPE_SZ */
static int try_pipe_resize(void) {
    int pipefd[2];
    if (pipe(pipefd) != 0) return 0;

    int cur = fcntl(pipefd[0], F_GETPIPE_SZ);
    int ret = fcntl(pipefd[0], F_SETPIPE_SZ, 1024 * 1024); /* 1MB */
    int after = fcntl(pipefd[0], F_GETPIPE_SZ);

    close(pipefd[0]);
    close(pipefd[1]);

    if (ret > 0 && after > cur) return after; /* New size */
    if (ret > 0) return after;
    return 0;
}

/* Test 2: splice() file-to-pipe */
static int try_splice_file_to_pipe(void) {
    g_got_sigsys = 0;

    int fd = open("/proc/self/status", O_RDONLY);
    if (fd < 0) return 0;

    int pipefd[2];
    if (pipe(pipefd) != 0) { close(fd); return 0; }

    loff_t off = 0;
    ssize_t n = splice(fd, &off, pipefd[1], NULL, 4096, SPLICE_F_MOVE);

    close(fd);
    close(pipefd[0]);
    close(pipefd[1]);

    if (g_got_sigsys) return -2;
    return (n > 0) ? 1 : 0;
}

/* Test 3: splice() pipe-to-file */
static int try_splice_pipe_to_file(void) {
    g_got_sigsys = 0;

    int pipefd[2];
    if (pipe(pipefd) != 0) return 0;

    /* Write something to the pipe */
    write(pipefd[1], "test data for splice\n", 21);

    char tmpname[] = "/tmp/splice_test_XXXXXX";
    int fd = mkstemp(tmpname);
    if (fd < 0) {
        close(pipefd[0]);
        close(pipefd[1]);
        return 0;
    }

    loff_t off = 0;
    ssize_t n = splice(pipefd[0], NULL, fd, &off, 4096, SPLICE_F_MOVE);

    close(fd);
    close(pipefd[0]);
    close(pipefd[1]);
    unlink(tmpname);

    if (g_got_sigsys) return -2;
    return (n > 0) ? 1 : 0;
}

/* Test 4: tee() pipe duplication */
static int try_tee(void) {
    g_got_sigsys = 0;

    int pipe1[2], pipe2[2];
    if (pipe(pipe1) != 0) return 0;
    if (pipe(pipe2) != 0) { close(pipe1[0]); close(pipe1[1]); return 0; }

    write(pipe1[1], "tee test data", 13);

    ssize_t n = tee(pipe1[0], pipe2[1], 4096, 0);

    close(pipe1[0]); close(pipe1[1]);
    close(pipe2[0]); close(pipe2[1]);

    if (g_got_sigsys) return -2;
    return (n > 0) ? 1 : 0;
}

/* Test 5: vmsplice() user-to-pipe */
static int try_vmsplice(void) {
    g_got_sigsys = 0;

    int pipefd[2];
    if (pipe(pipefd) != 0) return 0;

    char buf[] = "vmsplice payload data";
    struct iovec iov = {
        .iov_base = buf,
        .iov_len = sizeof(buf),
    };

    ssize_t n = vmsplice(pipefd[1], &iov, 1, SPLICE_F_GIFT);

    /* Read back to verify */
    char rbuf[64] = {0};
    if (n > 0) read(pipefd[0], rbuf, sizeof(rbuf));

    close(pipefd[0]);
    close(pipefd[1]);

    if (g_got_sigsys) return -2;
    if (n > 0 && strstr(rbuf, "vmsplice")) return 1;
    if (n > 0) return 2; /* vmsplice worked but data mismatch */
    return 0;
}

/* Test 6: Pipe capacity probing */
static int try_pipe_capacity(void) {
    char buf[256];
    int max_size = 0;

    ssize_t n = read_file("/proc/sys/fs/pipe-max-size", buf, sizeof(buf));
    if (n > 0) max_size = atoi(buf);

    /* Also check pipe-user-pages-soft */
    int user_pages = 0;
    n = read_file("/proc/sys/fs/pipe-user-pages-soft", buf, sizeof(buf));
    if (n > 0) user_pages = atoi(buf);

    return (max_size > 0 ? 1 : 0) | (user_pages > 0 ? 2 : 0);
}

/* Test 7: Pipe buffer exhaustion */
static int try_pipe_exhaust(void) {
    int count = 0;
    int fds[512]; /* 256 pipes = 512 fds */
    memset(fds, -1, sizeof(fds));

    for (int i = 0; i < 256; i++) {
        int pipefd[2];
        if (pipe(pipefd) != 0) break;
        fds[i*2] = pipefd[0];
        fds[i*2+1] = pipefd[1];

        /* Try to enlarge each pipe */
        fcntl(pipefd[0], F_SETPIPE_SZ, 64 * 1024);
        count++;
    }

    /* Cleanup */
    for (int i = 0; i < 512; i++)
        if (fds[i] >= 0) close(fds[i]);

    return count;
}

/* Test 8: Dirty Pipe pattern — splice then write to same pipe */
static int try_dirty_pipe_pattern(void) {
    g_got_sigsys = 0;

    /* This is the CVE-2022-0847 pattern:
     * 1. Create pipe, fill and drain to set PIPE_BUF_FLAG_CAN_MERGE
     * 2. splice a read-only file page into the pipe
     * 3. write to the pipe — on vulnerable kernels, this overwrites the page
     *
     * On patched kernels, step 3 creates a new page instead of overwriting.
     */

    int pipefd[2];
    if (pipe(pipefd) != 0) return 0;

    /* Step 1: Fill and drain the pipe to set CAN_MERGE on pages */
    char junk[4096];
    memset(junk, 'A', sizeof(junk));
    for (int i = 0; i < 16; i++) {
        write(pipefd[1], junk, sizeof(junk));
    }
    for (int i = 0; i < 16; i++) {
        read(pipefd[0], junk, sizeof(junk));
    }

    /* Step 2: splice a file page into the pipe */
    int fd = open("/proc/self/status", O_RDONLY);
    if (fd < 0) {
        close(pipefd[0]); close(pipefd[1]);
        return 0;
    }

    loff_t off = 0;
    ssize_t spliced = splice(fd, &off, pipefd[1], NULL, 1, SPLICE_F_MOVE);
    if (spliced <= 0) {
        close(fd); close(pipefd[0]); close(pipefd[1]);
        return 0;
    }

    /* Step 3: Write to the pipe — on vuln kernels, overwrites the file page */
    ssize_t written = write(pipefd[1], "PWNED", 5);

    /* Read back from the file to check if it was modified */
    char verify[64];
    lseek(fd, 1, SEEK_SET); /* Skip the 1 byte we spliced */
    ssize_t r = read(fd, verify, 5);

    close(fd);
    close(pipefd[0]);
    close(pipefd[1]);

    if (g_got_sigsys) return -2;

    /* If the file contains "PWNED", the kernel is vulnerable to Dirty Pipe */
    if (r >= 5 && memcmp(verify, "PWNED", 5) == 0) return 1; /* VULN! */
    if (written > 0 && spliced > 0) return 2; /* Pattern works but not vuln */
    return 0;
}

int main(void) {
    install_sigsys_handler();

    PRINT_HEADER("PIPE BUFFER EXPLOITATION PRIMITIVES");

    int resize = try_pipe_resize();
    TEST("pipe F_SETPIPE_SZ (info — heap spray sizing)",
         1,
         resize > 0 ? "resized to %d bytes" : "resize failed", resize);

    int splice_in = try_splice_file_to_pipe();
    TEST("splice file→pipe (info)",
         1,
         splice_in == 1  ? "works (file page in pipe buffer)" :
         splice_in == -2 ? "SIGSYS" : "blocked");

    int splice_out = try_splice_pipe_to_file();
    TEST("splice pipe→file (info)",
         1,
         splice_out == 1  ? "works (kernel-side file write)" :
         splice_out == -2 ? "SIGSYS" : "blocked");

    int tee_test = try_tee();
    TEST("tee() pipe duplication (info)",
         1,
         tee_test == 1  ? "works (zero-copy pipe dup)" :
         tee_test == -2 ? "SIGSYS" : "blocked");

    int vmsplice_test = try_vmsplice();
    TEST("vmsplice() blocked",
         vmsplice_test <= 0,
         vmsplice_test == 1  ? "WORKS — user-to-pipe zero-copy!" :
         vmsplice_test == 2  ? "WORKS — data mismatch" :
         vmsplice_test == -2 ? "SIGSYS" : "blocked");

    int cap = try_pipe_capacity();
    TEST("pipe capacity info (info)",
         1,
         cap == 3 ? "max-size + user-pages readable" :
         cap == 1 ? "max-size readable" :
         cap == 2 ? "user-pages readable" : "not readable");

    int exhaust = try_pipe_exhaust();
    TEST("pipe exhaustion (info)",
         1,
         "%d pipes created (64KB each)", exhaust);

    int dirty = try_dirty_pipe_pattern();
    TEST("Dirty Pipe (CVE-2022-0847) pattern blocked",
         dirty != 1,
         dirty == 1 ? "VULNERABLE — file page overwritten!" :
         dirty == 2 ? "pattern works, kernel patched" :
         dirty == -2 ? "SIGSYS" : "blocked");

    PRINT_SUMMARY();
    return g_fail ? 1 : 0;
}
